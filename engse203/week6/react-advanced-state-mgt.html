<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENGSE203: W6 - Advanced React & State Management</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html { scroll-behavior: smooth; }
        body { font-family: 'Sarabun', sans-serif; }
        .code-block {
            background-color: #1a202c; color: #e2e8f0; padding: 1.25rem;
            border-radius: 0.75rem; overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.9em; line-height: 1.6;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .result-block {
            background-color: #ffffff; border: 1px solid #e2e8f0;
            padding: 1.25rem; border-radius: 0.75rem; margin-top: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .sidebar-link.active {
            background-color: #3b82f6; color: white; font-weight: 700;
            transform: translateX(4px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .sidebar-link { transition: all 0.2s ease-in-out; }
        .sidebar-link:hover { background-color: #dbeafe; color: #1e3a8a; }
        .content-section { display: none; }
        .content-section.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .question-box {
            background-color: #fefce8; /* yellow-50 */
            border-left: 4px solid #facc15; /* yellow-400 */
            padding: 1rem; margin-top: 1.5rem; border-radius: 0.25rem;
        }
        .answer-box {
            background-color: #f0fdf4; /* green-50 */
            border-left: 4px solid #4ade80; /* green-400 */
            padding: 1rem; margin-top: 1rem; border-radius: 0.25rem;
            display: none;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <header class="bg-white shadow-sm p-4 sticky top-0 z-20">
        <div class="container mx-auto">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">ENGSE203: การเขียนโปรแกรมสำหรับวิศวกรซอฟต์แวร์</h1>
            <p class="text-lg text-blue-600 font-medium">สัปดาห์ที่ 6: Advanced React & State Management</p>
        </div>
    </header>

    <div class="container mx-auto flex flex-col md:flex-row mt-6">
        <aside id="sidebar" class="w-full md:w-1/4 lg:w-1/5 p-4 md:sticky md:top-24 self-start">
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-xl font-bold mb-4 text-gray-800">หัวข้อการเรียนรู้</h2>
                <nav><ul id="sidebar-nav" class="space-y-2"></ul></nav>
            </div>
        </aside>

        <main id="main-content" class="w-full md:w-3/4 lg:w-4/5 p-4"></main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const slides = [
                // Intro
                { id: 1, title: 'ภาพรวมสัปดาห์ที่ 6' },
                { id: 2, title: 'ทำไมต้องเรียน Advanced React?' },
                // Advanced Patterns
                { id: 3, title: 'ทบทวน: Custom Hooks' },
                { id: 4, title: 'Pattern: Higher-Order Components (HOC)' },
                { id: 5, title: 'HOC: ข้อดี-ข้อเสีย และคำถาม' },
                { id: 6, title: 'Pattern: Render Props' },
                { id: 7, title: 'Render Props vs Custom Hooks' },
                // State Management
                { id: 8, title: 'ปัญหา State Management และ Prop Drilling' },
                { id: 9, title: 'Context API: สำหรับ Global State' },
                { id: 10, 'title': 'Context API: ข้อควรระวังด้าน Performance' },
                { id: 11, 'title': 'รู้จัก Redux Toolkit (RTK)' },
                { id: 12, 'title': 'RTK: Core Concepts' },
                { id: 13, 'title': 'RTK: การสร้าง Slice' },
                { id: 14, 'title': 'RTK: เชื่อมต่อกับ React Component' },
                { id: 15, 'title': 'Context API vs Redux Toolkit' },
                // React Router
                { id: 16, 'title': 'Client-Side Routing คืออะไร?' },
                { id: 17, 'title': 'การติดตั้งและตั้งค่า React Router' },
                { id: 18, 'title': 'การสร้าง Routes และ Links' },
                { id: 19, 'title': 'Dynamic Routes ด้วย URL Params' },
                { id: 20, 'title': 'Nested Routes และ Outlet' },
                // Performance
                { id: 21, 'title': 'ทำไม Performance ถึงสำคัญ?' },
                { id: 22, 'title': 'Optimization: React.memo' },
                { id: 23, 'title': 'Optimization: useCallback' },
                { id: 24, 'title': 'Optimization: useMemo' },
                { id: 25, 'title': 'Code Splitting ด้วย React.lazy' },
                // Outro
                { id: 26, 'title': 'สรุปและกิจกรรม Lab' },
            ];

            const content = {
                1: `<h2 class="text-3xl font-bold mb-4">ภาพรวมสัปดาห์ที่ 6</h2><p class="mb-4 text-lg">จากสัปดาห์ที่แล้วที่เราเรียนรู้พื้นฐานของ React, สัปดาห์นี้เราจะลงลึกในหัวข้อขั้นสูงเพื่อสร้างแอปพลิเคชันที่ซับซ้อนและมีประสิทธิภาพมากขึ้น</p><h3 class="text-2xl font-bold mb-4">หัวข้อที่จะเรียน:</h3><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li><b>Advanced React Patterns:</b> เทคนิคการเขียนโค้ดเพื่อนำ Logic กลับมาใช้ซ้ำอย่างมีประสิทธิภาพ (HOC, Render Props, Custom Hooks)</li><li><b>State Management:</b> วิธีการจัดการ State ที่ซับซ้อนและแชร์ข้าม Components (Context API, Redux Toolkit)</li><li><b>React Router:</b> การสร้าง Single Page Applications (SPAs) ที่มีหลายหน้า</li><li><b>Performance Optimization:</b> เทคนิคทำให้แอปของเราทำงานเร็วขึ้น</li></ul><h3 class="text-2xl font-bold mb-4">เป้าหมายการเรียนรู้:</h3><p class="text-lg">เมื่อจบสัปดาห์นี้ นักศึกษาจะสามารถออกแบบและสร้าง React Application ที่มีความซับซ้อน, ขยายขนาดได้ (Scalable) และมีประสิทธิภาพสูง พร้อมสำหรับเชื่อมต่อกับ Backend API</p>`,
                2: `<h2 class="text-3xl font-bold mb-4">ทำไมต้องเรียน Advanced React?</h2><p class="mb-4 text-lg">เมื่อแอปพลิเคชันของเราใหญ่ขึ้น เราจะเจอปัญหาที่พื้นฐานอย่างเดียวอาจไม่พอ...</p><div class="grid md:grid-cols-2 gap-6"><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">1. การจัดการ State ที่ซับซ้อน</h3><p>เมื่อ State ต้องถูกแชร์ไปหลายๆ ที่ การส่ง Props ต่อๆ กันไปหลายทอด (Prop Drilling) จะทำให้โค้ดซับซ้อนและดูแลรักษายาก</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">2. Logic ที่ซ้ำซ้อน</h3><p>เราอาจมี Logic บางอย่าง (เช่น การดึงข้อมูล, การตรวจสอบสิทธิ์) ที่ต้องใช้ในหลาย Component การคัดลอกโค้ดไปวางไม่ใช่ทางออกที่ดี</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">3. Performance ตก</h3><p>การ Re-render ที่ไม่จำเป็นในแอปขนาดใหญ่สามารถทำให้แอปช้าลงอย่างเห็นได้ชัด เราต้องมีวิธีควบคุมสิ่งนี้</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">4. User Experience</h3><p>ผู้ใช้คาดหวังเว็บแอปที่เปลี่ยนหน้าได้ทันทีโดยไม่ต้องโหลดใหม่ทั้งหมด (Single Page Application) ซึ่งต้องใช้ Routing เข้ามาช่วย</p></div></div><p class="mt-6 text-lg bg-blue-100 p-4 rounded-lg">หัวข้อในวันนี้จะให้เครื่องมือและแนวคิดในการแก้ปัญหาเหล่านี้โดยตรง</p>`,
                3: `<h2 class="text-3xl font-bold mb-4">ทบทวน: Custom Hooks</h2><p class="mb-4 text-lg"><b>Custom Hooks</b> คือวิธีที่ทันสมัยและเป็นที่นิยมที่สุดในการสกัดและนำ State-related logic กลับมาใช้ซ้ำระหว่าง components</p><p class="mb-4">มันคือฟังก์ชัน JavaScript ที่ชื่อขึ้นต้นด้วย <code>use</code> และสามารถเรียกใช้ Hooks อื่นๆ ของ React ได้ (เช่น <code>useState</code>, <code>useEffect</code>)</p><h3 class="text-2xl font-bold mb-4">ตัวอย่าง: <code>useToggle</code></h3><pre class="code-block">// hooks/useToggle.js\nimport { useState, useCallback } from 'react';\n\nexport function useToggle(initialState = false) {\n  const [state, setState] = useState(initialState);\n  \n  // useCallback เพื่อให้ฟังก์ชัน toggle ไม่ถูกสร้างใหม่ทุกครั้งที่ re-render\n  const toggle = useCallback(() => setState(s => !s), []);\n  \n  return [state, toggle];\n}\n\n// การนำไปใช้ใน Component\nfunction MyComponent() {\n  const [isOpen, toggleIsOpen] = useToggle(false);\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={toggleIsOpen}&gt;\n        {isOpen ? 'Close' : 'Open'}\n      &lt;/button&gt;\n      {isOpen && &lt;p&gt;Content is visible!&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n}</pre><p class="mt-4 text-lg">Custom Hooks เป็นรากฐานที่สำคัญของ Advanced React Patterns ที่เราจะเรียนรู้ต่อไป</p>`,
                4: `<h2 class="text-3xl font-bold mb-4">Pattern: Higher-Order Components (HOC)</h2><p class="mb-4 text-lg">HOC เป็น Pattern ดั้งเดิมใน React (ก่อนยุค Hooks) มันคือ <b>ฟังก์ชัน</b> ที่รับ component เป็น argument และ return component ใหม่ออกมา โดยเสริมความสามารถ (props) เข้าไป</p><h3 class="text-2xl font-bold mb-4">แนวคิด: <code>HOC(WrappedComponent) => EnhancedComponent</code></h3><pre class="code-block">// HOC ที่จะเพิ่ม style ให้กับ Component ที่รับเข้ามา\nfunction withExtraStyles(WrappedComponent) {\n  // ...และ return component ใหม่ออกมา\n  return function(props) {\n    const style = {\n      border: '2px solid blue',\n      padding: '1rem',\n      borderRadius: '8px'\n    };\n\n    // Render Component เดิม พร้อมกับส่ง props ทั้งหมดที่มี และ props ใหม่ (style)\n    return &lt;WrappedComponent {...props} style={style} /&gt;;\n  };\n}\n\n// Component ธรรมดา\nfunction MyButton(props) {\n  return &lt;button style={props.style}&gt;Click Me!&lt;/button&gt;;\n}\n\n// นำ HOC มาใช้งาน\nconst EnhancedButton = withExtraStyles(MyButton);\n\n// ตอนใช้งานจริง\nfunction App() {\n  return &lt;EnhancedButton /&gt;;\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><button style="border: 2px solid blue; padding: 1rem; border-radius: 8px;">Click Me!</button></div>`,
                5: `<h2 class="text-3xl font-bold mb-4">HOC: ข้อดี-ข้อเสีย</h2><div class="grid md:grid-cols-2 gap-6"><div class="bg-green-100 p-4 rounded-lg">
<h3 class="text-xl font-bold mb-2 text-green-800">ข้อดี</h3><ul class="list-disc list-inside"><li>นำ Logic กลับมาใช้ซ้ำได้</li><li>แยก Logic ออกจาก UI (Separation of Concerns)</li></ul></div><div class="bg-red-100 p-4 rounded-lg">
<h3 class="text-xl font-bold mb-2 text-red-800">ข้อเสีย</h3><ul class="list-disc list-inside"><li><b>Wrapper Hell:</b> การใช้ HOC ซ้อนกันหลายๆ ชั้นทำให้ React DevTools ดูยาก</li><li><b>Props Collision:</b> HOC อาจส่ง props ที่ชื่อซ้ำกับ props เดิมของ Component</li><li><b>Source of Props is Unclear:</b> ไม่ชัดเจนว่า props ที่ Component ได้รับมาจากไหน</li></ul></div></div><div class="question-box"><p class="font-bold">คำถามชวนคิด 🤔</p><p>จากข้อเสียที่กล่าวมา โดยเฉพาะความซับซ้อนและไม่ชัดเจนของที่มา props, นักศึกษาคิดว่า <b>Custom Hooks</b> แก้ปัญหานี้ได้อย่างไร?</p><button class="mt-2 text-sm text-blue-600 font-semibold" onclick="toggleAnswer(this)">แสดง/ซ่อนเฉลย</button><div class="answer-box"><p class="font-bold">เฉลย:</p><p>Custom Hooks แก้ปัญหาได้โดยตรง เพราะ Logic และ State ถูกเรียกใช้ "ภายใน" component อย่างชัดเจน เราสามารถเห็นได้ทันทีว่า <code>const [value, setValue] = useMyHook()</code> มาจากไหน และไม่มีการสร้าง component ครอบเพิ่มเติม ทำให้โค้ดแบนราบ (flat) และติดตามง่ายกว่า</p></div></div>`,
                6: `<h2 class="text-3xl font-bold mb-4">Pattern: Render Props</h2><p class="mb-4 text-lg">เป็นอีกหนึ่ง Pattern (ก่อนยุค Hooks) ที่ใช้ในการแชร์โค้ดระหว่าง components. แนวคิดคือ component จะรับ prop หนึ่งซึ่งเป็น <b>ฟังก์ชัน</b> (โดยทั่วไปจะชื่อ <code>render</code>) และ component นั้นจะเรียกใช้ฟังก์ชันนี้เพื่อ render UI แทนที่จะ render UI ของตัวเองโดยตรง</p><h3 class="text-2xl font-bold mb-4">ตัวอย่าง: <code>MouseTracker</code></h3><p class="mb-2">Component นี้จะติดตามตำแหน่งของเมาส์ แต่จะไม่ render UI ใดๆ เอง แต่จะส่งตำแหน่ง (x, y) ไปให้ฟังก์ชัน <code>render</code> ที่ได้รับมา</p><pre class="code-block">// Component ที่ใช้ pattern Render Props\nfunction MouseTracker({ render }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  const handleMouseMove = (event) => {\n    setPosition({ x: event.clientX, y: event.clientY });\n  };\n\n  return (\n    &lt;div style={{ height: '200px', border: '1px solid black' }} onMouseMove={handleMouseMove}&gt;\n      {/* เรียกใช้ render prop และส่ง state ภายในออกไป */}\n      {render(position)}\n    &lt;/div&gt;\n  );\n}\n\n// การนำไปใช้\nfunction App() {\n  return (\n    &lt;MouseTracker render={({ x, y }) => (\n      &lt;h1&gt;The mouse position is ({x}, {y})&lt;/h1&gt;\n    )} /&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4><div id="render-prop-app"></div></div>`,
                7: `<h2 class="text-3xl font-bold mb-4">Render Props vs Custom Hooks</h2><p class="mb-4 text-lg">ทั้ง Render Props และ Custom Hooks แก้ปัญหาการแชร์ Logic ได้ แต่ปัจจุบัน <b>Custom Hooks</b> เป็นที่นิยมมากกว่าอย่างชัดเจน</p><h3 class="text-2xl font-bold mb-4">ลองเปลี่ยน <code>MouseTracker</code> เป็น Custom Hook</h3><pre class="code-block">// hooks/useMousePosition.js\nfunction useMousePosition() {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setPosition({ x: event.clientX, y: event.clientY });\n    };\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n\n  return position;\n}\n\n// การนำไปใช้ใน Component\nfunction App() {\n  const { x, y } = useMousePosition();\n  return &lt;h1&gt;The mouse position is ({x}, {y})&lt;/h1&gt;;\n}</pre><div class="question-box"><p class="font-bold">คำถามชวนคิด 🤔</p><p>เปรียบเทียบโค้ด 2 แบบนี้ นักศึกษาคิดว่า Custom Hook ดีกว่า Render Props ในแง่ไหนบ้าง?</p><button class="mt-2 text-sm text-blue-600 font-semibold" onclick="toggleAnswer(this)">แสดง/ซ่อนเฉลย</button><div class="answer-box"><p class="font-bold">เฉลย:</p><ul class="list-disc list-inside"><li><b>Simpler:</b> โค้ดสั้นกว่ามาก ไม่มี JSX ที่ซ้อนกัน (No Wrapper Hell)</li><li><b>More Composable:</b> เราสามารถใช้ Custom Hooks หลายๆ อันใน component เดียวกันได้อย่างง่ายดาย</li><li><b>Clearer Data Source:</b> เห็นได้ชัดว่า state (position) มาจาก <code>useMousePosition()</code></li></ul></div></div>`,
                8: `<h2 class="text-3xl font-bold mb-4">ปัญหา State Management และ Prop Drilling</h2><p class="mb-4 text-lg">เมื่อแอปพลิเคชันของเรามีขนาดใหญ่ขึ้น การส่งข้อมูล (state) ผ่าน props ไปยัง component ลูกที่อยู่ลึกๆ หลายชั้นจะกลายเป็นปัญหาที่เรียกว่า <b>"Prop Drilling"</b></p><img src="https://placehold.co/800x250/dbeafe/1e3a8a?text=Prop+Drilling+Diagram" alt="Prop Drilling Diagram" class="rounded-lg shadow-md my-4"><pre class="code-block">// ตัวอย่าง Prop Drilling\n// App ส่ง user data ไปให้ Page, Page ส่งต่อไปให้ UserProfile, UserProfile ส่งต่อไปให้ Avatar\n// ทั้งๆ ที่ Page และ UserProfile อาจไม่ได้ใช้ข้อมูล user เลย\n\nfunction App() {\n  const [user, setUser] = useState({ name: 'John', avatarUrl: '...' });\n  return &lt;Page user={user} /&gt;;\n}\n\nfunction Page({ user }) {\n  return &lt;UserProfile user={user} /&gt;;\n}\n\nfunction UserProfile({ user }) {\n  return &lt;Avatar user={user} /&gt;;\n}\n\nfunction Avatar({ user }) {\n  return &lt;img src={user.avatarUrl} alt={user.name} /&gt;;\n}</pre><div class="question-box"><p class="font-bold">คำถามชวนคิด 🤔</p><p>Prop Drilling ทำให้เกิดปัญหาอะไรบ้างในการพัฒนาและดูแลรักษาโค้ด?</p><button class="mt-2 text-sm text-blue-600 font-semibold" onclick="toggleAnswer(this)">แสดง/ซ่อนเฉลย</button><div class="answer-box"><p class="font-bold">เฉลย:</p><ul class="list-disc list-inside"><li><b>Hard to Refactor:</b> การแก้ไขโครงสร้างข้อมูล state จะต้องตามไปแก้ props ในทุก component ที่ข้อมูลวิ่งผ่าน</li><li><b>Code Verbosity:</b> โค้ดจะยาวและซ้ำซ้อนโดยไม่จำเป็น</li><li><b>Reusability Issues:</b> Component ตรงกลางจะผูกติดกับ props ที่ต้องส่งผ่าน ทำให้เอากลับไปใช้ในที่อื่นได้ยาก</li></ul></div></div>`,
                9: `<h2 class="text-3xl font-bold mb-4">Context API: สำหรับ Global State</h2><p class="mb-4 text-lg">Context API เป็นเครื่องมือของ React ที่สร้างมาเพื่อแก้ปัญหา Prop Drilling โดยเฉพาะ มันทำให้เราสามารถสร้าง "state ส่วนกลาง" ที่ component ใดๆ ใน tree ก็สามารถเข้าถึงได้โดยตรง</p><h3 class="text-2xl font-bold mb-4">ขั้นตอนการใช้งาน</h3><ol class="list-decimal list-inside space-y-2 mb-4 text-lg"><li><b>สร้าง Context:</b> ใช้ <code>createContext()</code></li><li><b>สร้าง Provider:</b> สร้าง component ที่จะ "ส่ง" ค่า state ลงไปใน context</li><li><b>เรียกใช้ Context:</b> ใช้ hook <code>useContext()</code> ใน component ที่ต้องการใช้ state นั้น</li></ol><pre class="code-block">// 1. สร้าง Context (AuthContext.js)\nimport { createContext } from 'react';\nexport const AuthContext = createContext(null);\n\n// 2. สร้าง Provider (App.js)\nimport { AuthContext } from './AuthContext';\nfunction App() {\n  const [currentUser, setCurrentUser] = useState({ name: 'Somsak' });\n  return (\n    &lt;AuthContext.Provider value={currentUser}&gt;\n      &lt;Page /&gt;\n    &lt;/AuthContext.Provider&gt;\n  );\n}\n\n// 3. เรียกใช้ Context (Avatar.js - อยู่ลึกแค่ไหนก็ได้)\nimport { useContext } from 'react';\nimport { AuthContext } from './AuthContext';\nfunction Avatar() {\n  const user = useContext(AuthContext);\n  return &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;;\n}</pre><p class="mt-4 text-lg">สังเกตว่า <code>Page</code> และ <code>UserProfile</code> ไม่ต้องรับหรือส่งต่อ prop <code>user</code> อีกต่อไป!</p>`,
                10: `<h2 class="text-3xl font-bold mb-4">Context API: ข้อควรระวังด้าน Performance</h2><p class="mb-4 text-lg">แม้ Context API จะสะดวก แต่ก็มีข้อควรระวังสำคัญ: <b>ทุกครั้งที่ค่าใน Provider เปลี่ยน, ทุก component ที่เรียกใช้ <code>useContext</code> จาก Provider นั้นจะ re-render ทั้งหมด</b></p><pre class="code-block">function App() {\n  const [user, setUser] = useState({ name: 'Somsak', theme: 'light' });\n\n  // สร้าง value object ใหม่ทุกครั้งที่ App re-render\n  const value = { user, setUser }; \n\n  return (\n    &lt;UserContext.Provider value={value}&gt;\n      &lt;Header /&gt;   {/* Header ใช้แค่ user.name */}\n      &lt;ThemeSwitcher /&gt; {/* ThemeSwitcher ใช้แค่ user.theme */}\n    &lt;/UserContext.Provider&gt;\n  );\n}</pre><p class="mb-4 text-lg">ในตัวอย่างนี้ ถ้าเราเปลี่ยน theme, state <code>user</code> จะเปลี่ยน ทำให้ <code>Header</code> re-render ไปด้วยโดยไม่จำเป็น เพราะ <code>user.name</code> ไม่ได้เปลี่ยน</p><h3 class="text-2xl font-bold mb-4">แนวทางแก้ไข</h3><ul class="list-disc list-inside space-y-2 text-lg"><li><b>แยก Context:</b> สร้าง Context แยกสำหรับข้อมูลที่ไม่ค่อยเกี่ยวข้องกัน เช่น <code>UserContext</code> และ <code>ThemeContext</code></li><li><b>Memoization:</b> ใช้ <code>useMemo</code> เพื่อป้องกันการสร้าง value object ใหม่โดยไม่จำเป็น และใช้ <code>React.memo</code> กับ component ลูก</li></ul><div class="question-box"><p class="font-bold">คำถามชวนคิด 🤔</p><p>Context API เหมาะกับข้อมูลประเภทไหน และไม่เหมาะกับข้อมูลประเภทไหน?</p><button class="mt-2 text-sm text-blue-600 font-semibold" onclick="toggleAnswer(this)">แสดง/ซ่อนเฉลย</button><div class="answer-box"><p class="font-bold">เฉลย:</p><p><b>เหมาะกับ:</b> Global state ที่เปลี่ยนแปลงไม่บ่อย เช่น ข้อมูลผู้ใช้ที่ login อยู่, theme (dark/light mode), หรือภาษาที่เลือก</p><p><b>ไม่เหมาะกับ:</b> State ที่มีการอัปเดตบ่อยๆ และมีความซับซ้อนสูง (เช่น state ของทั้งแอปพลิเคชัน) เพราะจะทำให้เกิด re-render ที่ไม่จำเป็นจำนวนมาก ซึ่งเป็นที่มาของ Library อย่าง Redux</p></div></div>`,
                11: `<h2 class="text-3xl font-bold mb-4">รู้จัก Redux Toolkit (RTK)</h2><p class="mb-4 text-lg"><b>Redux</b> เป็น library สำหรับจัดการ state ที่ได้รับความนิยมสูงสุด แต่การตั้งค่าแบบดั้งเดิมค่อนข้างซับซ้อนและมี boilerplate code เยอะ</p><p class="mb-4 text-lg"><b>Redux Toolkit (RTK)</b> คือเครื่องมือที่ทีม Redux สร้างขึ้นมาเอง เป็นวิธีที่ "แนะนำอย่างเป็นทางการ" สำหรับการเขียน Redux ในปัจจุบัน</p><h3 class="text-2xl font-bold mb-4">ทำไมต้องใช้ RTK?</h3><div class="grid md:grid-cols-2 gap-6"><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">✅ Simple</h3><p>ลด Boilerplate Code ลงอย่างมาก ทำให้โค้ดสั้นลงและเข้าใจง่ายขึ้น</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">✅ Opinionated</h3><p>มีแนวทางปฏิบัติที่ดีที่สุด (Best Practices) มาให้ในตัว เช่น การใช้ Immer สำหรับ immutable updates</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">✅ Powerful</h3><p>มาพร้อมกับเครื่องมือที่มีประโยชน์ เช่น <code>createSlice</code> สำหรับสร้าง reducer และ actions อัตโนมัติ และ <code>RTK Query</code> สำหรับ data fetching</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">✅ Effective</h3><p>ช่วยให้จัดการ state ที่ซับซ้อนและมีการอัปเดตบ่อยๆ ได้อย่างมีประสิทธิภาพและคาดเดาได้ (predictable)</p></div></div>`,
                12: `<h2 class="text-3xl font-bold mb-4">RTK: Core Concepts</h2><p class="mb-4 text-lg">การทำงานของ Redux มี data flow ทางเดียว (Unidirectional Data Flow) ซึ่งทำให้ง่ายต่อการติดตามและ debug</p><img src="https://placehold.co/800x300/e0e7ff/3730a3?text=Redux+Data+Flow" alt="Redux Data Flow Diagram" class="rounded-lg shadow-md my-4"><ol class="list-decimal list-inside space-y-4 text-lg"><li><b>Action:</b> Object ที่อธิบายว่า "เกิดอะไรขึ้น" (เช่น <code>{ type: 'todos/addTodo', payload: 'Learn RTK' }</code>)</li><li><b>Dispatch:</b> ฟังก์ชันที่ใช้ส่ง Action เข้าไปในระบบ</li><li><b>Reducer:</b> ฟังก์ชันบริสุทธิ์ (Pure Function) ที่รับ state ปัจจุบันและ action เข้ามา แล้วคืนค่าเป็น state ใหม่</li><li><b>Store:</b> Object ที่เก็บ state ทั้งหมดของแอปพลิเคชันไว้ที่เดียว</li><li><b>View (React Component):</b> อ่านข้อมูลจาก Store มาแสดงผล และ dispatch action เมื่อผู้ใช้มี tương tác</li></ol>`,
                13: `<h2 class="text-3xl font-bold mb-4">RTK: การสร้าง Slice</h2><p class="mb-4 text-lg">ใน RTK เราจะแบ่ง state ออกเป็นส่วนๆ เรียกว่า <b>"Slices"</b>. ฟังก์ชัน <code>createSlice</code> จะช่วยสร้าง reducer และ action creators ให้เราโดยอัตโนมัติจาก object เดียว</p><pre class="code-block">// features/counter/counterSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = { value: 0 };\n\nconst counterSlice = createSlice({\n  name: 'counter', // ชื่อของ slice\n  initialState,   // state เริ่มต้น\n  // Reducers: object ที่ key คือชื่อ action และ value คือฟังก์ชัน reducer\n  reducers: {\n    increment(state) {\n      // RTK ใช้ Immer เบื้องหลัง ทำให้เราเขียนโค้ดแบบแก้ไข state โดยตรงได้!\n      state.value += 1;\n    },\n    decrement(state) {\n      state.value -= 1;\n    },\n    incrementByAmount(state, action) {\n      // action.payload คือข้อมูลที่ส่งมากับ action\n      state.value += action.payload;\n    },\n  },\n});\n\n// createSlice จะสร้าง action creators ให้เราอัตโนมัติ\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// Export ตัว reducer เพื่อนำไปรวมใน store\nexport default counterSlice.reducer;</pre>`,
                14: `<h2 class="text-3xl font-bold mb-4">RTK: เชื่อมต่อกับ React Component</h2><p class="mb-4 text-lg">เราจะใช้ React-Redux library เพื่อเชื่อมต่อ RTK store กับ React components</p><h3 class="text-2xl font-bold mb-2">1. ตั้งค่า Store และ Provider</h3><pre class="code-block">// app/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer, // นำ reducer จาก slice มาใส่\n  },\n});\n\n// main.jsx\nimport { Provider } from 'react-redux';\nimport { store } from './app/store';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;\n);</pre><h3 class="text-2xl font-bold mt-4 mb-2">2. อ่าน State และ Dispatch Actions ใน Component</h3><pre class="code-block">// features/counter/Counter.jsx\nimport { useSelector, useDispatch } from 'react-redux';\nimport { increment, decrement } from './counterSlice';\n\nexport function Counter() {\n  // useSelector: สำหรับดึงข้อมูลจาก store\n  const count = useSelector((state) => state.counter.value);\n  // useDispatch: สำหรับส่ง action\n  const dispatch = useDispatch();\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() => dispatch(increment())}&gt;+&lt;/button&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;button onClick={() => dispatch(decrement())}&gt;-&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</pre>`,
                15: `<h2 class="text-3xl font-bold mb-4">Context API vs Redux Toolkit</h2><p class="mb-4 text-lg">แล้วเราควรเลือกใช้อะไรดี? ทั้งสองอย่างมีจุดเด่นและกรณีการใช้งานที่เหมาะสมต่างกัน</p><div class="overflow-x-auto"><table class="w-full text-left border-collapse"><thead><tr><th class="border-b-2 p-2">Feature</th><th class="border-b-2 p-2">Context API</th><th class="border-b-2 p-2">Redux Toolkit</th></tr></thead><tbody><tr class="border-b"><td class="p-2"><b>กรณีใช้งานหลัก</b></td><td class="p-2">State ที่เปลี่ยนไม่บ่อย (Theme, Auth)</td><td class="p-2">State ที่ซับซ้อน, เปลี่ยนบ่อย, มี business logic เยอะ</td></tr><tr class="border-b"><td class="p-2"><b>Performance</b></td><td class="p-2">Re-render ทุก consumer เมื่อ value เปลี่ยน</td><td class="p-2">Optimized, re-render เฉพาะ component ที่ state ส่วนนั้นเปลี่ยน</td></tr><tr class="border-b"><td class="p-2"><b>Boilerplate</b></td><td class="p-2">น้อยมาก (Built-in)</td><td class="p-2">น้อยกว่า Redux เดิม แต่ยังมากกว่า Context</td></tr><tr class="border-b"><td class="p-2"><b>DevTools</b></td><td class="p-2">ไม่มีโดยเฉพาะ (ใช้ React DevTools)</td><td class="p-2">มี Redux DevTools ที่ทรงพลังมาก (Time-travel debugging)</td></tr></tbody></table></div><div class="question-box"><p class="font-bold">คำแนะนำ 👍</p><p><b>เริ่มต้นด้วย Context API ก่อนเสมอ</b> สำหรับ state ง่ายๆ ที่ต้องแชร์กัน. หากแอปพลิเคชันเริ่มซับซ้อน, state มีการอัปเดตบ่อยครั้งจนเกิดปัญหา performance, หรือต้องการเครื่องมือ debug ที่ดีขึ้น, <b>ค่อยพิจารณาใช้ Redux Toolkit</b></p></div>`,
                16: `<h2 class="text-3xl font-bold mb-4">Client-Side Routing คืออะไร?</h2><p class="mb-4 text-lg">ในเว็บแบบดั้งเดิม (Server-Side Routing) ทุกครั้งที่ผู้ใช้คลิกลิงก์เพื่อเปลี่ยนหน้า, เบราว์เซอร์จะส่ง request ไปยัง server และ server จะส่งหน้า HTML ใหม่กลับมาทั้งหมด ทำให้เกิดการโหลดหน้าใหม่ (full page reload)</p><p class="mb-4 text-lg"><b>Client-Side Routing</b> คือเทคนิคที่ใช้ใน <b>Single Page Applications (SPAs)</b>. เมื่อผู้ใช้คลิกลิงก์, JavaScript (ในที่นี้คือ React Router) จะเข้ามาจัดการ URL ในเบราว์เซอร์และ render component ที่เหมาะสมใหม่ <b>โดยไม่มีการโหลดหน้าใหม่</b></p><h3 class="text-2xl font-bold mb-4">ข้อดีของ Client-Side Routing</h3><ul class="list-disc list-inside space-y-2 text-lg"><li><b>🚀 Fast & Smooth:</b> ให้ความรู้สึกเหมือนใช้แอปพลิเคชันบนเดสก์ท็อป เพราะไม่มีการกระพริบจากการโหลดหน้าใหม่</li><li><b>✨ Better User Experience:</b> สามารถสร้าง transition และ animation ระหว่างการเปลี่ยนหน้าได้</li><li><b>📉 Reduced Server Load:</b> หลังจากโหลดแอปครั้งแรกแล้ว การสื่อสารกับ server จะเน้นที่การรับ-ส่งข้อมูล (API) เท่านั้น ไม่ต้องส่ง HTML ทั้งหน้า</li></ul>`,
                17: `<h2 class="text-3xl font-bold mb-4">การติดตั้งและตั้งค่า React Router</h2><p class="mb-4 text-lg">เราจะใช้ library ที่เป็นมาตรฐานของวงการคือ <code>react-router-dom</code></p><h3 class="text-2xl font-bold mb-2">1. การติดตั้ง</h3><pre class="code-block">npm install react-router-dom</pre><h3 class="text-2xl font-bold mt-4 mb-2">2. การตั้งค่า <code>BrowserRouter</code></h3><p class="mb-2">เราต้องครอบแอปพลิเคชันของเราด้วย <code>&lt;BrowserRouter&gt;</code> ในไฟล์ระดับบนสุด (โดยทั่วไปคือ <code>main.jsx</code>) เพื่อเปิดใช้งานความสามารถของ routing</p><pre class="code-block">// src/main.jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  &lt;React.StrictMode&gt;\n    &lt;BrowserRouter&gt;\n      &lt;App /&gt;\n    &lt;/BrowserRouter&gt;\n  &lt;/React.StrictMode&gt;\n);</pre><p class="mt-4 text-lg">เมื่อทำขั้นตอนนี้เสร็จ แอปของเราก็พร้อมที่จะกำหนด routes หรือเส้นทางต่างๆ แล้ว</p>`,
                18: `<h2 class="text-3xl font-bold mb-4">การสร้าง Routes และ Links</h2><p class="mb-4 text-lg">เราจะใช้ component หลักๆ 3 ตัวในการกำหนดหน้าและสร้างลิงก์:</p><ul class="list-disc list-inside space-y-2 mb-4"><li><code>&lt;Routes&gt;</code>: เป็นตัวครอบ <code>&lt;Route&gt;</code> ทั้งหมด</li><li><code>&lt;Route&gt;</code>: กำหนดว่าที่ path ไหน จะให้ render component อะไร</li><li><code>&lt;Link&gt;</code>: ใช้สร้างลิงก์สำหรับเปลี่ยนหน้า (จะถูก render เป็นแท็ก <code>&lt;a&gt;</code>)</li></ul><pre class="code-block">// App.jsx\nimport { Routes, Route, Link } from 'react-router-dom';\n\n// สร้าง Page Components\nconst HomePage = () => &lt;h1&gt;Home Page&lt;/h1&gt;;\nconst AboutPage = () => &lt;h1&gt;About Us&lt;/h1&gt;;\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;nav&gt;\n        &lt;Link to="/"&gt;Home&lt;/Link&gt; | \n        &lt;Link to="/about"&gt;About&lt;/Link&gt;\n      &lt;/nav&gt;\n\n      &lt;hr /&gt;\n\n      &lt;Routes&gt;\n        &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;\n        &lt;Route path="/about" element={&lt;AboutPage /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์ (Mockup):</h4><nav class="mb-2"><a href="#" class="text-blue-600">Home</a> | <a href="#" class="text-blue-600">About</a></nav><hr/><div class="mt-2 p-4 bg-gray-100 rounded-lg"><h1>Home Page</h1></div></div>`,
                19: `<h2 class="text-3xl font-bold mb-4">Dynamic Routes ด้วย URL Params</h2><p class="mb-4 text-lg">บ่อยครั้งเราต้องการสร้าง Route ที่เป็นแบบ dynamic เช่น หน้าโปรไฟล์ของผู้ใช้ <code>/users/1</code>, <code>/users/2</code>. เราสามารถทำได้โดยใช้ URL Parameters ใน path (ขึ้นต้นด้วย <code>:</code>)</p><p class="mb-2">เราจะใช้ hook <code>useParams</code> เพื่อดึงค่า parameter นั้นออกมาใช้งาน</p><pre class="code-block">// UserProfile.jsx\nimport { useParams } from 'react-router-dom';\n\nfunction UserProfile() {\n  // useParams จะ return object ที่มี key ตรงกับที่เราตั้งใน path\n  const { userId } = useParams();\n\n  // เราสามารถนำ userId ไป fetch ข้อมูลผู้ใช้จาก API ได้\n  return &lt;h1&gt;Profile page for User ID: {userId}&lt;/h1&gt;;\n}\n\n// App.jsx (เพิ่ม Route)\nimport { Routes, Route, Link } from 'react-router-dom';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;nav&gt;\n        &lt;Link to="/users/1"&gt;User 1&lt;/Link&gt; | \n        &lt;Link to="/users/2"&gt;User 2&lt;/Link&gt;\n      &lt;/nav&gt;\n      &lt;Routes&gt;\n        {/* path=":userId" คือการบอกว่าส่วนนี้เป็น dynamic parameter */}\n        &lt;Route path="/users/:userId" element={&lt;UserProfile /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์ (Mockup):</h4><p>เมื่อคลิก "User 1", URL จะเป็น <code>/users/1</code> และหน้าเว็บจะแสดง: <b>Profile page for User ID: 1</b></p></div>`,
                20: `<h2 class="text-3xl font-bold mb-4">Nested Routes และ Outlet</h2><p class="mb-4 text-lg">Nested Routes คือการซ้อน Route เข้าไปข้างใน Route อื่น ซึ่งมีประโยชน์มากสำหรับการสร้าง Layout ที่ใช้ร่วมกัน เช่น Dashboard ที่มี Sidebar คงที่ แต่เนื้อหาตรงกลางเปลี่ยนไป</p><p class="mb-2">เราจะใช้ component <code>&lt;Outlet /&gt;</code> ใน Layout component เพื่อบอก React Router ว่า "จะให้ render child route ตรงนี้นะ"</p><pre class="code-block">// DashboardLayout.jsx\nimport { Link, Outlet } from 'react-router-dom';\n\nfunction DashboardLayout() {\n  return (\n    &lt;div className="dashboard"&gt;\n      &lt;aside className="sidebar"&gt;\n        &lt;Link to="/dashboard"&gt;Overview&lt;/Link&gt;\n        &lt;Link to="/dashboard/settings"&gt;Settings&lt;/Link&gt;\n      &lt;/aside&gt;\n      &lt;main className="content"&gt;\n        {/* Child routes (Overview, Settings) จะถูก render ตรงนี้ */}\n        &lt;Outlet /&gt;\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n\n// App.jsx (กำหนด Nested Routes)\n&lt;Routes&gt;\n  &lt;Route path="/dashboard" element={&lt;DashboardLayout /&gt;}&gt;\n    &lt;Route index element={&lt;p&gt;Dashboard Overview&lt;/p&gt;} /&gt; { /* Route สำหรับ /dashboard */}\n    &lt;Route path="settings" element={&lt;p&gt;Account Settings&lt;/p&gt;} /&gt; { /* Route สำหรับ /dashboard/settings */}\n  &lt;/Route&gt;\n&lt;/Routes&gt;</pre>`,
                21: `<h2 class="text-3xl font-bold mb-4">ทำไม Performance ถึงสำคัญ?</h2><p class="mb-4 text-lg">การเขียนโค้ดให้ทำงานได้เป็นแค่ก้าวแรก การทำให้มันทำงานได้ "ดี" และ "เร็ว" เป็นสิ่งสำคัญอย่างยิ่งในโลกของเว็บแอปพลิเคชัน</p><div class="grid md:grid-cols-3 gap-6 text-center"><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">User Experience</h3><p>ผู้ใช้จะออกจากเว็บที่โหลดช้าหรือกระตุก เว็บที่เร็วให้ความรู้สึกที่ดีและน่าเชื่อถือกว่า</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">Conversion Rates</h3><p>สำหรับเว็บ E-commerce, ทุกๆ วินาทีที่โหลดช้าลงหมายถึงโอกาสในการขายที่ลดลง</p></div><div class="bg-white p-6 rounded-lg shadow">
<h3 class="text-xl font-bold mb-2">SEO</h3><p>Google ใช้ความเร็วในการโหลดหน้าเว็บ (Core Web Vitals) เป็นปัจจัยหนึ่งในการจัดอันดับการค้นหา</p></div></div><p class="mt-6 text-lg">ใน React, ปัญหา performance ส่วนใหญ่มักเกิดจาก <b>"การ re-render ที่ไม่จำเป็น"</b>. เราจะเรียนรู้เทคนิคในการป้องกันสิ่งนี้</p>`,
                22: `<h2 class="text-3xl font-bold mb-4">Optimization: React.memo</h2><p class="mb-4 text-lg"><code>React.memo</code> เป็น Higher-Order Component ที่ใช้ครอบ function component เพื่อป้องกันการ re-render หาก <b>props</b> ที่ส่งเข้ามาไม่มีการเปลี่ยนแปลง</p><h3 class="text-2xl font-bold mb-4">ตัวอย่างปัญหา</h3><pre class="code-block">function App() {\n  const [count, setCount] = useState(0);\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() => setCount(c => c + 1)}&gt;Count: {count}&lt;/button&gt;\n      {/* ทุกครั้งที่ count เปลี่ยน App จะ re-render ทำให้ Header re-render ไปด้วย */}\n      &lt;Header title="My App" /&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction Header({ title }) {\n  console.log('Header is rendering!');\n  return &lt;h1&gt;{title}&lt;/h1&gt;;\n}</pre><h3 class="text-2xl font-bold mt-4 mb-4">การแก้ไขด้วย <code>React.memo</code></h3><p class="mb-2">เพียงแค่ครอบ component ที่เราไม่ต้องการให้ re-render โดยไม่จำเป็นด้วย <code>React.memo</code></p><pre class="code-block">import React, { memo } from 'react';\n\nconst Header = memo(function Header({ title }) {\n  console.log('Header is rendering!');\n  return &lt;h1&gt;{title}&lt;/h1&gt;;\n});</pre><div class="result-block"><p><b>ผลลัพธ์:</b> เมื่อกดปุ่ม "Count", <code>console.log</code> จาก <code>Header</code> จะแสดงผลแค่ครั้งแรกเท่านั้น เพราะ props <code>title</code> ไม่เคยเปลี่ยนแปลง</p></div>`,
                23: `<h2 class="text-3xl font-bold mb-4">Optimization: useCallback</h2><p class="mb-4 text-lg"><code>React.memo</code> จะไม่ได้ผลถ้าเราส่ง props ที่เป็นฟังก์ชันเข้าไป เพราะฟังก์ชันจะถูกสร้างขึ้นใหม่ทุกครั้งที่ parent re-render ทำให้ props เปลี่ยนแปลงเสมอ</p><p class="mb-2"><code>useCallback</code> คือ Hook ที่ใช้แก้ปัญหานี้โดยการ "memoize" (จำ) ฟังก์ชันนั้นไว้ มันจะคืนค่าฟังก์ชันเดิมกลับมาตราบใดที่ค่าใน dependency array ยังไม่เปลี่ยนแปลง</p><pre class="code-block">function App() {\n  const [count, setCount] = useState(0);\n\n  // ใช้ useCallback เพื่อให้ฟังก์ชัน handleDelete ไม่ถูกสร้างใหม่ทุกครั้ง\n  const handleDelete = useCallback(() => {\n    console.log('Item deleted!');\n  }, []); // dependency array ว่างเปล่า = สร้างฟังก์ชันนี้แค่ครั้งเดียว\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={() => setCount(c => c + 1)}&gt;Count: {count}&lt;/button&gt;\n      {/* ตอนนี้ ListItem จะไม่ re-render เมื่อ count เปลี่ยน */}\n      &lt;ListItem onDelete={handleDelete} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// ListItem ถูกครอบด้วย React.memo\nconst ListItem = memo(function ListItem({ onDelete }) {\n  console.log('ListItem is rendering!');\n  return &lt;button onClick={onDelete}&gt;Delete&lt;/button&gt;;\n});</pre>`,
                24: `<h2 class="text-3xl font-bold mb-4">Optimization: useMemo</h2><p class="mb-4 text-lg">ในขณะที่ <code>useCallback</code> ใช้จำฟังก์ชัน, <code>useMemo</code> ใช้สำหรับจำ <b>"ผลลัพธ์"</b> ของการคำนวณที่ใช้เวลานาน</p><p class="mb-2">การคำนวณจะทำงานอีกครั้งก็ต่อเมื่อค่าใน dependency array เปลี่ยนไปเท่านั้น เหมาะสำหรับกรองข้อมูล, เรียงลำดับ, หรือคำนวณค่าที่ซับซ้อนจาก list ขนาดใหญ่</p><pre class="code-block">function TodoList({ todos, filter }) {\n  // การกรอง todos อาจใช้เวลานานถ้า list ใหญ่มาก\n  // useMemo จะช่วยให้การกรองนี้ทำงานใหม่ก็ต่อเมื่อ todos หรือ filter เปลี่ยนเท่านั้น\n  const visibleTodos = useMemo(() => {\n    console.log('Filtering todos...');\n    return todos.filter(t => t.text.includes(filter));\n  }, [todos, filter]);\n\n  return (\n    &lt;ul&gt;\n      {visibleTodos.map(todo => (&lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;))}\n    &lt;/ul&gt;\n  );\n}\n\nfunction App() {\n  // ... state for todos, filter, and another unrelated state like 'count'\n  // เมื่อ 'count' เปลี่ยน, App จะ re-render แต่ TodoList จะไม่คำนวณ visibleTodos ใหม่\n  // เพราะ todos และ filter ไม่ได้เปลี่ยน\n}</pre>`,
                25: `<h2 class="text-3xl font-bold mb-4">Code Splitting ด้วย React.lazy</h2><p class="mb-4 text-lg">โดยปกติแล้ว Vite/Webpack จะรวมโค้ด JavaScript ทั้งหมดของแอปไว้ในไฟล์เดียว (bundle). เมื่อแอปมีขนาดใหญ่ ไฟล์นี้ก็จะใหญ่ตามไปด้วย ทำให้ใช้เวลาโหลดครั้งแรกนาน</p><p class="mb-2"><b>Code Splitting</b> คือเทคนิคการแบ่ง bundle ออกเป็นไฟล์เล็กๆ หลายๆ ไฟล์ และโหลดเฉพาะส่วนที่จำเป็นในตอนนั้นๆ</p><p class="mb-2">React มี <code>React.lazy</code> และ <code>&lt;Suspense&gt;</code> มาให้เพื่อทำสิ่งนี้ได้อย่างง่ายดาย</p><pre class="code-block">import React, { Suspense } from 'react';\n\n// ใช้ React.lazy เพื่อ import component แบบ dynamic\nconst AdminDashboard = React.lazy(() => import('./pages/AdminDashboard'));\nconst UserProfile = React.lazy(() => import('./pages/UserProfile'));\n\nfunction App() {\n  return (\n    &lt;BrowserRouter&gt;\n      {/* Suspense จะแสดง fallback UI (เช่น Loading...) ระหว่างรอโหลด component */}\n      &lt;Suspense fallback={&lt;div&gt;Loading page...&lt;/div&gt;}&gt;\n        &lt;Routes&gt;\n          &lt;Route path="/profile" element={&lt;UserProfile /&gt;} /&gt;\n          &lt;Route path="/admin" element={&lt;AdminDashboard /&gt;} /&gt;\n        &lt;/Routes&gt;\n      &lt;/Suspense&gt;\n    &lt;/BrowserRouter&gt;\n  );\n}</pre><div class="result-block"><p><b>ผลลัพธ์:</b> โค้ดของ <code>AdminDashboard</code> จะถูกโหลดก็ต่อเมื่อผู้ใช้เข้าไปที่ URL <code>/admin</code> เท่านั้น ทำให้การโหลดหน้าแรกเร็วขึ้นมาก</p></div>`,
                26: `<h2 class="text-3xl font-bold mb-4">สรุปและกิจกรรม Lab</h2><h3 class="text-2xl font-bold mb-4">สรุปเนื้อหาสัปดาห์ที่ 6</h3><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li>เราได้เรียนรู้ Advanced Patterns (HOC, Render Props) และเห็นว่าทำไม <b>Custom Hooks</b> ถึงเป็นวิธีที่ดีกว่าในการแชร์ Logic</li><li>เราเข้าใจปัญหา <b>Prop Drilling</b> และเรียนรู้วิธีแก้ด้วย <b>Context API</b> สำหรับ Global State ที่เปลี่ยนไม่บ่อย และ <b>Redux Toolkit</b> สำหรับ State ที่ซับซ้อน</li><li>เราสามารถสร้าง Single Page Application ที่มีหลายหน้าได้ด้วย <b>React Router</b> รวมถึงการทำ Dynamic และ Nested Routes</li><li>เราเรียนรู้เทคนิคการทำ Performance Optimization ที่สำคัญคือ <b><code>memo</code></b>, <b><code>useCallback</code></b>, <b><code>useMemo</code></b> และ <b><code>React.lazy</code></b></li></ul><h3 class="text-2xl font-bold mb-4">กิจกรรม Lab</h3><p class="text-lg">สร้าง Mini E-commerce Application โดยใช้ความรู้ทั้งหมดที่เรียนมา:</p><ol class="list-decimal list-inside space-y-2 text-lg"><li><b>Routing:</b> สร้างหน้า Home, Products, Product Detail (dynamic), และ Cart</li><li><b>State Management:</b> ใช้ Redux Toolkit สร้าง <code>cartSlice</code> เพื่อจัดการสินค้าในตะกร้า (เพิ่ม, ลบ, เปลี่ยนจำนวน)</li><li><b>Data Fetching:</b> ในหน้า Products, ดึงข้อมูลสินค้าจาก Public API (เช่น Fake Store API)</li><li><b>Performance:</b> ใช้ <code>React.memo</code> กับ Product Card component และใช้ <code>useCallback</code> สำหรับฟังก์ชัน "Add to Cart"</li></ol>`,
            };
            
            // --- Helper functions for interactive mockups ---
            const createInteractiveRenderProp = (containerId) => {
                const container = document.getElementById(containerId);
                if(!container) return;
                const render = (position) => {
                     container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div style="height: 200px; border: 2px dashed #9ca3af; display: flex; align-items: center; justify-content: center; flex-direction: column; background: #f9fafb; border-radius: 0.5rem;">
                            <p class="text-gray-500">Move your mouse over this area</p>
                            <h2 class="text-2xl font-bold mt-2">The mouse position is (${position.x}, ${position.y})</h2>
                        </div>
                    `;
                };
                container.addEventListener('mousemove', e => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    render({ x: Math.round(e.clientX - rect.left), y: Math.round(e.clientY - rect.top) });
                });
                render({x: 0, y: 0});
            };

            // --- Main script ---
            const sidebarNav = document.getElementById('sidebar-nav');
            const mainContent = document.getElementById('main-content');

            // Generate sidebar links and content sections
            slides.forEach((slide) => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#slide-${slide.id}`;
                a.textContent = `${slide.id}. ${slide.title}`;
                a.classList.add('sidebar-link', 'block', 'p-2', 'rounded-md', 'text-gray-700');
                a.dataset.target = `slide-${slide.id}`;
                li.appendChild(a);
                sidebarNav.appendChild(li);

                const section = document.createElement('div');
                section.id = `slide-${slide.id}`;
                section.classList.add('content-section', 'bg-white', 'p-6', 'rounded-lg', 'shadow');
                section.innerHTML = content[slide.id] || `<h2 class="text-3xl font-bold mb-4">${slide.title}</h2><p>เนื้อหาสำหรับส่วนนี้กำลังเตรียมการ</p>`;
                mainContent.appendChild(section);
            });

            // Make toggleAnswer globally accessible for inline onclick
            window.toggleAnswer = (button) => {
                const answerBox = button.nextElementSibling;
                if (answerBox.style.display === 'none' || answerBox.style.display === '') {
                    answerBox.style.display = 'block';
                } else {
                    answerBox.style.display = 'none';
                }
            };
            
            createInteractiveRenderProp('render-prop-app');

            const sidebarLinks = document.querySelectorAll('.sidebar-link');
            const contentSections = document.querySelectorAll('.content-section');

            function showContent(targetId) {
                let found = false;
                contentSections.forEach(section => {
                    if (section.id === targetId) {
                        section.classList.add('active');
                        found = true;
                    } else {
                        section.classList.remove('active');
                    }
                });

                if (!found) {
                    contentSections[0]?.classList.add('active');
                    targetId = contentSections[0]?.id;
                }

                sidebarLinks.forEach(link => {
                    if (link.dataset.target === targetId) {
                        link.classList.add('active');
                    } else {
                        link.classList.remove('active');
                    }
                });
            }

            sidebarNav.addEventListener('click', function(e) {
                e.preventDefault();
                const link = e.target.closest('.sidebar-link');
                if (link) {
                    const targetId = link.dataset.target;
                    showContent(targetId);
                    window.location.hash = targetId;
                }
            });

            const handleHashChange = () => {
                const targetId = window.location.hash ? window.location.hash.substring(1) : 'slide-1';
                showContent(targetId);
            };

            window.addEventListener('hashchange', handleHashChange);
            handleHashChange();
        });
    </script>
</body>
</html>
