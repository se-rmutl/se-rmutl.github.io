<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENGSE203: Interactive React.js Lecture</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'Sarabun', sans-serif;
        }
        .code-block {
            background-color: #1a202c; /* gray-900 */
            color: #e2e8f0; /* gray-300 */
            padding: 1.25rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            font-size: 0.9em;
            line-height: 1.6;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .result-block {
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* gray-200 */
            padding: 1.25rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .sidebar-link.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            font-weight: 700;
            transform: translateX(4px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .sidebar-link {
            transition: all 0.2s ease-in-out;
        }
        .sidebar-link:hover {
            background-color: #dbeafe; /* blue-100 */
            color: #1e3a8a; /* blue-900 */
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .user-card {
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            background-color: white;
        }
        .error {
            color: #ef4444; /* red-500 */
            font-size: 0.875rem;
            margin-top: 0.25rem;
            display: block;
        }
        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header -->
    <header class="bg-white shadow-sm p-4 sticky top-0 z-20">
        <div class="container mx-auto">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">ENGSE203: การเขียนโปรแกรมสำหรับวิศวกรซอฟต์แวร์</h1>
            <p class="text-lg text-blue-600 font-medium">สัปดาห์ที่ 5: Frontend Framework - React.js (2025)</p>
        </div>
    </header>

    <div class="container mx-auto flex flex-col md:flex-row mt-6">
        <!-- Sidebar Navigation -->
        <aside id="sidebar" class="w-full md:w-1/4 lg:w-1/5 p-4 md:sticky md:top-24 self-start">
            <div class="bg-white rounded-lg shadow p-4">
                <h2 class="text-xl font-bold mb-4 text-gray-800">หัวข้อการเรียนรู้</h2>
                <nav>
                    <ul id="sidebar-nav" class="space-y-2">
                        <!-- Links will be generated by JS -->
                    </ul>
                </nav>
            </div>
        </aside>

        <!-- Main Content -->
        <main id="main-content" class="w-full md:w-3/4 lg:w-4/5 p-4">
            <!-- Content sections will be generated by JS -->
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Data for all slides
            const slides = [
                { id: 1, title: 'Course Overview' }, { id: 2, title: 'What is React.js?' }, { id: 3, title: 'Environment Setup' }, { id: 4, title: 'JSX Syntax Basics' }, { id: 5, title: 'JavaScript in JSX' }, { id: 6, title: 'Your First React Component' }, { id: 7, title: 'Understanding Props' }, { id: 8, title: 'Props Destructuring' }, { id: 9, title: 'Introduction to React Hooks' }, { id: 10, title: 'useState Hook - Basics' }, { id: 11, title: 'useState with Different Data Types' }, { id: 12, title: 'useState with Objects and Arrays' }, { id: 13, title: 'useState with Arrays' }, { id: 14, title: 'Event Handling in React' }, { id: 15, title: 'Event Object and Synthetic Events' }, { id: 16, title: 'useEffect Hook - Introduction' }, { id: 17, title: 'useEffect Dependencies' }, { id: 18, title: 'useEffect Cleanup' }, { id: 19, title: 'Fetching Data with useEffect' }, { id: 20, title: 'useContext Hook - Introduction' }, { id: 21, title: 'Using Context' }, { id: 22, title: 'Component Composition' }, { id: 23, title: 'Conditional Rendering' }, { id: 24, title: 'Lists and Keys' }, { id: 25, title: 'Forms in React' }, { id: 26, title: 'Form Validation' }, { id: 27, title: 'Component Design Patterns' }, { id: 28, title: 'Higher-Order Components (HOC)' }, { id: 29, title: 'Custom Hooks' }, { id: 30, title: 'Performance Optimization Basics' }, { id: 31, title: 'Error Handling' }, { id: 32, title: 'Project Structure Best Practices' }, { id: 33, title: 'Practical Example - Todo App' }, { id: 34, title: 'Lab Activities Overview' }, { id: 35, title: 'Summary and Next Steps' }
            ];

            const content = {
                1: `<h2 class="text-3xl font-bold mb-4">จุดประสงค์การเรียนรู้</h2><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li>เข้าใจพื้นฐาน React.js และ JSX syntax</li><li>สามารถสร้าง React components และจัดการ Props</li><li>เรียนรู้การใช้ React Hooks (useState, useEffect, useContext)</li><li>เข้าใจการจัดการ Event handling ใน React</li></ul><h2 class="text-3xl font-bold mb-4">ผลลัพธ์การเรียนรู้</h2><p class="mb-2 text-lg">หลังจากเรียนจบ นักศึกษาจะสามารถ:</p><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li>สร้าง React application พื้นฐานได้</li><li>ออกแบบ Component architecture</li><li>จัดการ State และ Props อย่างมีประสิทธิภาพ</li><li>ใช้ React Hooks ในการพัฒนา</li></ul><div class="bg-blue-100 border-l-4 border-blue-500 text-blue-800 p-4 rounded-r-lg" role="alert"><p class="font-bold">เวลาเรียน</p><p>1-2 ชั่วโมง + Lab 3 ชั่วโมง</p></div>`,
                2: `<h2 class="text-3xl font-bold mb-4">React คืออะไร?</h2><p class="mb-6 text-lg">React เป็น JavaScript library สำหรับสร้าง User Interfaces โดยเฉพาะ Web Applications</p><h3 class="text-2xl font-bold mb-4">คุณสมบัติเด่นของ React (2025)</h3><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li><b>Component-Based Architecture</b> - แบ่งแยก UI เป็นชิ้นส่วนเล็กๆ ที่นำกลับมาใช้ใหม่ได้</li><li><b>Virtual DOM</b> - ประสิทธิภาพสูงในการอัปเดตและ render UI</li><li><b>Declarative</b> - บอก React ว่าต้องการให้ UI หน้าตาเป็นอย่างไร แล้ว React จะจัดการที่เหลือเอง</li><li><b>React Server Components</b> - สำหรับการ render บน server เพื่อ performance ที่ดีขึ้น</li><li><b>Concurrent Features</b> - การจัดการ rendering ที่ซับซ้อนพร้อมๆ กันได้ดีขึ้น</li></ul><h3 class="text-2xl font-bold mb-4">ทำไมต้องเรียน React?</h3><ul class="list-disc list-inside space-y-2 text-lg"><li>ได้รับความนิยมสูงสุดในวงการ Frontend</li><li>Community ใหญ่และ ecosystem แข็งแกร่ง (มีเครื่องมือและ library ให้ใช้มากมาย)</li><li>เป็นที่ต้องการของตลาดงานสูง</li></ul>`,
                3: `<h2 class="text-3xl font-bold mb-4">Environment Setup</h2><h3 class="text-xl font-semibold mb-2">การติดตั้ง Node.js และ npm</h3><p class="mb-2">ตรวจสอบ version ใน terminal:</p><pre class="code-block">node --version\nnpm --version</pre><h3 class="text-xl font-semibold mt-6 mb-2">สร้าง React App ด้วย Vite (2025 Recommended)</h3><p class="mb-2">Vite เป็นเครื่องมือสร้างโปรเจคที่รวดเร็วและทันสมัย</p><pre class="code-block"># สร้างโปรเจคใหม่ชื่อ my-react-app\nnpm create vite@latest my-react-app -- --template react\n\n# เข้าไปในโฟลเดอร์โปรเจค\ncd my-react-app\n\n# ติดตั้ง dependencies\nnpm install\n\n# รัน development server\nnpm run dev</pre><h3 class="text-xl font-semibold mt-6 mb-2">โครงสร้างโปรเจค</h3><pre class="code-block">my-react-app/\n├── public/         # เก็บไฟล์สาธารณะ เช่น favicon\n├── src/            # โฟลเดอร์หลักที่เราจะทำงาน\n│   ├── assets/     # เก็บไฟล์รูปภาพ, CSS\n│   ├── App.jsx     # Component หลักของแอป\n│   └── main.jsx    # จุดเริ่มต้นของแอป\n├── package.json    # ข้อมูลโปรเจคและ dependencies\n└── vite.config.js  # ไฟล์ตั้งค่า Vite</pre>`,
                4: `<h2 class="text-3xl font-bold mb-4">JSX Syntax Basics</h2><h3 class="text-xl font-semibold mb-2">JSX คืออะไร?</h3><p class="mb-4 text-lg">JSX (JavaScript XML) เป็นส่วนขยายของ JavaScript ที่ช่วยให้เราเขียนโค้ดที่หน้าตาคล้าย HTML ได้ภายในไฟล์ JavaScript ซึ่งทำให้การสร้าง UI ง่ายและเห็นภาพชัดเจนขึ้น</p><h3 class="text-xl font-semibold mb-2">กฎของ JSX</h3><p class="mb-2"><b>1. ต้องมี Parent Element เดียว:</b> JSX expression ต้องมี element ครอบเพียงอันเดียวเสมอ</p><pre class="code-block">// ✅ ถูกต้อง - ใช้ div เป็น parent\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello World&lt;/h1&gt;\n      &lt;p&gt;Welcome to React&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n// ✅ หรือใช้ Fragment (&lt;&gt;) ถ้าไม่ต้องการสร้าง div เพิ่ม\nfunction App() {\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Hello World&lt;/h1&gt;\n      &lt;p&gt;Welcome to React&lt;/p&gt;\n    &lt;/&gt;\n  );\n}</pre><h3 class="text-xl font-semibold mt-6 mb-2">2. ความแตกต่างจาก HTML</h3><p class="mb-2">HTML attributes บางตัวจะถูกเปลี่ยนเป็นแบบ camelCase ใน JSX เพื่อไม่ให้ชนกับ keyword ของ JavaScript</p><pre class="code-block">&lt;div className="container"&gt;  &lt;!-- 'class' ใน HTML กลายเป็น 'className' --&gt;\n&lt;label htmlFor="name"&gt;     &lt;!-- 'for' ใน HTML กลายเป็น 'htmlFor' --&gt;\n&lt;input onChange={handleChange} /&gt; &lt;!-- event listeners เป็น camelCase เช่น 'onclick' -> 'onClick' --&gt;</pre>`,
                5: `<h2 class="text-3xl font-bold mb-4">JavaScript in JSX</h2><p class="mb-4 text-lg">เราสามารถใช้ JavaScript expression ได้เกือบทุกชนิดภายใน JSX โดยการใส่ไว้ในวงเล็บปีกกา <code>{}</code></p><h3 class="text-xl font-semibold mb-2">การใช้ JavaScript Expression</h3><pre class="code-block">function Greeting() {\n  const name = "React";\n  const year = 2025;\n  \n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;\n      &lt;p&gt;Welcome to year {year}.&lt;/p&gt;\n      &lt;p&gt;2 * 2 = {2 * 2}&lt;/p&gt;\n      &lt;p&gt;Status: {year > 2024 ? "Future" : "Past"}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><div class="border p-4 rounded-md"><h1 class="text-2xl font-bold">Hello, React!</h1><p>Welcome to year 2025.</p><p>2 * 2 = 4</p><p>Status: Future</p></div></div>`,
                6: `<h2 class="text-3xl font-bold mb-4">Your First React Component</h2><p class="mb-4 text-lg">Component คือหัวใจของ React มันคือฟังก์ชัน JavaScript ที่ return JSX เพื่ออธิบายว่า UI ส่วนนั้นๆ ควรหน้าตาเป็นอย่างไร</p><h3 class="text-xl font-semibold mb-2">การสร้าง Function Component</h3><p class="mb-2">สร้างไฟล์ <code>components/Welcome.jsx</code></p><pre class="code-block">// components/Welcome.jsx\nfunction Welcome() {\n  return (\n    &lt;div className="p-4 bg-green-100 rounded-lg"&gt;\n      &lt;h1 className="text-xl font-bold text-green-800"&gt;Welcome to React!&lt;/h1&gt;\n      &lt;p className="text-green-700"&gt;This is my first component.&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Welcome;</pre><h3 class="text-xl font-semibold mt-6 mb-2">การนำ Component ไปใช้</h3><p class="mb-2">ในไฟล์ <code>App.jsx</code> เราสามารถ import และนำมาใช้ซ้ำได้เหมือน HTML tag</p><pre class="code-block">// App.jsx\nimport Welcome from './components/Welcome';\n\nfunction App() {\n  return (\n    &lt;div className="App space-y-4"&gt;\n      &lt;Welcome /&gt;\n      &lt;Welcome /&gt;  &lt;!-- สามารถใช้ซ้ำได้ (Reusable) --&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><div class="space-y-4"><div class="p-4 bg-green-100 rounded-lg"><h1 class="text-xl font-bold text-green-800">Welcome to React!</h1><p class="text-green-700">This is my first component.</p></div><div class="p-4 bg-green-100 rounded-lg"><h1 class="text-xl font-bold text-green-800">Welcome to React!</h1><p class="text-green-700">This is my first component.</p></div></div></div>`,
                7: `<h2 class="text-3xl font-bold mb-4">Understanding Props</h2><h3 class="text-xl font-semibold mb-2">Props คืออะไร?</h3><p class="mb-4 text-lg">Props (ย่อมาจาก Properties) คือข้อมูลที่เราส่งจาก <b>parent component</b> (ตัวแม่) ไปยัง <b>child component</b> (ตัวลูก) ทำให้เราสามารถสร้าง component ที่ยืดหยุ่นและนำกลับมาใช้ใหม่ได้กับข้อมูลที่แตกต่างกัน</p><h3 class="text-xl font-semibold mb-2">การส่ง Props (จาก Parent)</h3><pre class="code-block">// Parent Component: App.jsx\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;UserCard name="John Doe" age={25} city="Bangkok" /&gt;\n      &lt;UserCard name="Jane Smith" age={30} city="Chiang Mai" /&gt;\n    &lt;/div&gt;\n  );\n}</pre><h3 class="text-xl font-semibold mt-6 mb-2">การรับ Props (ใน Child)</h3><p class="mb-2">Child component จะได้รับ props มาเป็น object</p><pre class="code-block">// Child Component: UserCard.jsx\nfunction UserCard(props) {\n  return (\n    &lt;div className="user-card"&gt;\n      &lt;h2 className="text-xl font-bold"&gt;{props.name}&lt;/h2&gt;\n      &lt;p&gt;Age: {props.age}&lt;/p&gt;\n      &lt;p&gt;City: {props.city}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><div class="space-y-4"><div class="user-card"><h2 class="text-xl font-bold">John Doe</h2><p>Age: 25</p><p>City: Bangkok</p></div><div class="user-card"><h2 class="text-xl font-bold">Jane Smith</h2><p>Age: 30</p><p>City: Chiang Mai</p></div></div></div>`,
                8: `<h2 class="text-3xl font-bold mb-4">Props Destructuring</h2><p class="mb-4 text-lg">เพื่อให้โค้ดสั้นและอ่านง่ายขึ้น เราสามารถใช้ ES6 Destructuring เพื่อดึงค่าจาก object <code>props</code> ได้โดยตรงใน parameter ของฟังก์ชัน</p><h3 class="text-xl font-semibold mb-2">การใช้ Destructuring</h3><pre class="code-block">// แทนที่จะเขียน props.name, props.age\nfunction UserCard({ name, age, city }) {\n  return (\n    &lt;div className="user-card"&gt;\n      &lt;h2 className="text-xl font-bold"&gt;{name}&lt;/h2&gt;\n      &lt;p&gt;Age: {age}&lt;/p&gt;\n      &lt;p&gt;City: {city}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</pre><h3 class="text-xl font-semibold mt-6 mb-2">Default Props</h3><p class="mb-2">เราสามารถกำหนดค่าเริ่มต้นให้กับ props ได้ ในกรณีที่ parent ไม่ได้ส่งค่ามาให้</p><pre class="code-block">function UserCard({ name, age = 18, city = "Unknown" }) {\n  return (\n    &lt;div className="user-card"&gt;\n      &lt;h2 className="text-xl font-bold"&gt;{name}&lt;/h2&gt;\n      &lt;p&gt;Age: {age}&lt;/p&gt;\n      &lt;p&gt;City: {city}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n// การใช้งาน: &lt;UserCard name="John" /&gt;</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์จากการใช้ <code>&lt;UserCard name="John" /&gt;</code>:</h4><div class="user-card"><h2 class="text-xl font-bold">John</h2><p>Age: 18</p><p>City: Unknown</p></div></div>`,
                9: `<h2 class="text-3xl font-bold mb-4">Introduction to React Hooks</h2><h3 class="text-xl font-semibold mb-2">Hooks คืออะไร?</h3><p class="mb-4 text-lg">Hooks เป็นฟังก์ชันพิเศษที่ช่วยให้ Function Components สามารถ "เกี่ยว" เข้ากับ state และ lifecycle features ของ React ได้ โดยไม่ต้องเขียน Class Component</p><h3 class="text-xl font-semibold mb-2">กฎของ Hooks (Rules of Hooks)</h3><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li><b>เรียกใช้ Hooks ที่ Top Level เท่านั้น:</b> ห้ามเรียก Hooks ภายใน loops, conditions, หรือ nested functions</li><li><b>เรียกใช้ Hooks ใน React Functions เท่านั้น:</b> เรียกได้จาก Function Components หรือ Custom Hooks เท่านั้น</li></ul><h3 class="text-xl font-semibold mb-2">Built-in Hooks ที่สำคัญ</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="bg-gray-200 p-4 rounded-lg"><b>useState</b> - สำหรับจัดการ state ใน component</div><div class="bg-gray-200 p-4 rounded-lg"><b>useEffect</b> - สำหรับจัดการ side effects (เช่น API calls)</div><div class="bg-gray-200 p-4 rounded-lg"><b>useContext</b> - สำหรับเข้าถึงข้อมูลจาก Context API</div><div class="bg-gray-200 p-4 rounded-lg"><b>useReducer</b> - สำหรับจัดการ state ที่ซับซ้อน (เป็นทางเลือกของ useState)</div><div class="bg-gray-200 p-4 rounded-lg"><b>useMemo</b> - สำหรับ optimization โดยการจำค่าที่คำนวณไว้</div><div class="bg-gray-200 p-4 rounded-lg"><b>useCallback</b> - สำหรับ optimization โดยการจำฟังก์ชันไว้</div></div>`,
                10: `<h2 class="text-3xl font-bold mb-4">useState Hook - Basics</h2><p class="mb-4 text-lg"><code>useState</code> เป็น Hook พื้นฐานที่สุดสำหรับเพิ่ม state เข้าไปใน function component</p><h3 class="text-xl font-semibold mb-2">การใช้งาน</h3><p class="mb-2"><code>useState</code> รับ <b>initialValue</b> (ค่าเริ่มต้น) และคืนค่ากลับมาเป็น array ที่มี 2 สมาชิก:</p><ol class="list-decimal list-inside mb-4"><li><b>state:</b> ค่า state ปัจจุบัน</li><li><b>setter function:</b> ฟังก์ชันสำหรับอัปเดตค่า state</li></ol><pre class="code-block">import { useState } from 'react';\n\nfunction Counter() {\n  // [currentValue, setterFunction] = useState(initialValue)\n  const [count, setCount] = useState(0);\n  \n  return (\n    &lt;div&gt;\n      &lt;h2 className="text-2xl"&gt;Count: {count}&lt;/h2&gt;\n      &lt;button className="m-1 px-4 py-2 bg-blue-500 text-white rounded" onClick={() => setCount(count + 1)}&gt;Increase&lt;/button&gt;\n      &lt;button className="m-1 px-4 py-2 bg-yellow-500 text-white rounded" onClick={() => setCount(count - 1)}&gt;Decrease&lt;/button&gt;\n      &lt;button className="m-1 px-4 py-2 bg-red-500 text-white rounded" onClick={() => setCount(0)}&gt;Reset&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4><div id="counter-app" class="text-center"></div></div>`,
                11: `<h2 class="text-3xl font-bold mb-4">useState with Different Data Types</h2><p class="mb-4 text-lg">State สามารถเก็บข้อมูลได้ทุกประเภท ไม่ว่าจะเป็น String, Boolean, Object, หรือ Array</p><h3 class="text-xl font-semibold mb-2">String State</h3><pre class="code-block">function NameInput() {\n  const [name, setName] = useState('');\n  \n  return (\n    &lt;div&gt;\n      &lt;input \n        type="text" \n        className="form-input"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        placeholder="Enter your name"\n      /&gt;\n      &lt;p className="mt-2 text-lg"&gt;Hello, {name || 'stranger'}!&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</pre><div id="name-input-app" class="result-block"></div><h3 class="text-xl font-semibold mt-6 mb-2">Boolean State</h3><pre class="code-block">function ToggleExample() {\n  const [isVisible, setIsVisible] = useState(true);\n  \n  return (\n    &lt;div&gt;\n      &lt;button className="px-4 py-2 bg-indigo-500 text-white rounded" onClick={() => setIsVisible(!isVisible)}&gt;\n        {isVisible ? 'Hide' : 'Show'} Message\n      &lt;/button&gt;\n      {isVisible && &lt;p className="mt-2 p-4 bg-indigo-100 rounded-lg"&gt;This message can be toggled!&lt;/p&gt;}\n    &lt;/div&gt;\n  );\n}</pre><div id="toggle-app" class="result-block"></div>`,
                12: `<h2 class="text-3xl font-bold mb-4">useState with Objects and Arrays</h2><p class="mb-4 text-lg">เมื่อทำงานกับ Object หรือ Array ใน state สิ่งสำคัญคือต้องปฏิบัติตามหลัก <b>Immutability</b> คือ "ห้ามแก้ไข state เดิมโดยตรง" แต่ให้ "สร้างของใหม่" ขึ้นมาแทน</p><h3 class="text-xl font-semibold mb-2">Object State</h3><p class="mb-2">ใช้ Spread Syntax <code>(...)</code> เพื่อคัดลอก object เดิม แล้วจึงเขียนทับ property ที่ต้องการแก้ไข</p><pre class="code-block">function UserProfile() {\n  const [user, setUser] = useState({ name: '', email: '' });\n  \n  const handleNameChange = (e) => {\n    setUser(prevUser => ({\n      ...prevUser,           // 1. คัดลอก user เดิมทั้งหมด\n      name: e.target.value  // 2. เขียนทับเฉพาะ name\n    }));\n  };\n  \n  // ... handleEmailChange is similar\n\n  return (\n    &lt;div&gt;\n      &lt;input className="form-input" placeholder="Name" onChange={handleNameChange} /&gt;\n      &lt;p&gt;Name: {user.name}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}</pre><div id="object-state-app" class="result-block"></div>`,
                13: `<h2 class="text-3xl font-bold mb-4">useState with Arrays</h2><p class="mb-4 text-lg">หลักการ Immutability ยังคงใช้กับ Array เช่นกัน</p><h3 class="text-xl font-semibold mb-2">การเพิ่ม Item</h3><p class="mb-2">ใช้ Spread Syntax <code>[...]</code> เพื่อสร้าง array ใหม่ที่ประกอบด้วย item เดิมทั้งหมด และเพิ่ม item ใหม่เข้าไป</p><pre class="code-block">const addTodo = () => {\n  setTodos([...todos, newTodo]); // ✅ ถูกต้อง\n  // todos.push(newTodo);       // ❌ ผิด! ห้ามแก้ไข state เดิม\n};</pre><h3 class="text-xl font-semibold mt-6 mb-2">การลบ Item</h3><p class="mb-2">ใช้เมธอด <code>.filter()</code> ซึ่งจะคืนค่าเป็น array ใหม่เสมอ</p><pre class="code-block">const removeTodo = (idToRemove) => {\n  setTodos(todos.filter(todo => todo.id !== idToRemove));\n};</pre><h3 class="text-xl font-semibold mt-6 mb-2">การแก้ไข Item</h3><p class="mb-2">ใช้เมธอด <code>.map()</code> เพื่อสร้าง array ใหม่ โดยเปลี่ยนเฉพาะ item ที่ต้องการ</p><pre class="code-block">const toggleTodo = (idToToggle) => {\n  setTodos(todos.map(todo => \n    todo.id === idToToggle ? { ...todo, completed: !todo.completed } : todo\n  ));\n};</pre><div id="array-state-app" class="result-block"></div>`,
                14: `<h2 class="text-3xl font-bold mb-4">Event Handling in React</h2><p class="mb-4 text-lg">การจัดการ event ใน React คล้ายกับ HTML DOM แต่มีข้อแตกต่างที่สำคัญ:</p><ul class="list-disc list-inside space-y-2 mb-4"><li>Event ใน React จะเขียนในรูปแบบ <b>camelCase</b> (เช่น <code>onClick</code> แทน <code>onclick</code>)</li><li>เราจะส่ง <b>function</b> เข้าไปในวงเล็บปีกกา <code>{}</code> แทนที่จะเป็น string</li></ul><pre class="code-block">function EventExample() {\n  const [message, setMessage] = useState('No event yet.');\n\n  const handleClick = () => {\n    setMessage('Button was clicked!');\n  };\n\n  const handleInputChange = (event) => {\n    setMessage('Input value: ' + event.target.value);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // ป้องกัน page reload เมื่อ submit form\n    alert('Form submitted!');\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit} className="space-y-4"&gt;\n      &lt;div&gt;\n        &lt;button type="button" className="px-4 py-2 bg-blue-500 text-white rounded" onClick={handleClick}&gt;Click Me&lt;/button&gt;\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;input className="form-input" onChange={handleInputChange} placeholder="Type something..." /&gt;\n      &lt;/div&gt;\n      &lt;button type="submit" className="px-4 py-2 bg-green-500 text-white rounded"&gt;Submit&lt;/button&gt;\n      &lt;p className="p-4 bg-gray-100 rounded-lg"&gt;Status: {message}&lt;/p&gt;\n    &lt;/form&gt;\n  );\n}</pre><div id="event-handling-app" class="result-block"></div>`,
                15: `<h2 class="text-3xl font-bold mb-4">Event Object and Synthetic Events</h2><p class="mb-4 text-lg">React จะส่ง <b>SyntheticEvent</b> object มาให้ event handlers ซึ่งเป็น wrapper ที่ทำงานเหมือนกันในทุก browser ทำให้เราไม่ต้องกังวลเรื่อง cross-browser compatibility. เราสามารถเข้าถึง property ของ event ได้เหมือนกับ DOM event ปกติ เช่น <code>event.target</code></p><h3 class="text-xl font-semibold mb-2">การส่ง Arguments ให้ Event Handlers</h3><p class="mb-2">หากต้องการส่งค่าเพิ่มเติมเข้าไปใน handler (นอกเหนือจาก event object) ให้ใช้ arrow function</p><pre class="code-block">function ButtonList() {\n  const handleButtonClick = (buttonName, event) => {\n    console.log(\`\${buttonName} was clicked.\`);\n    console.log('Event type:', event.type);\n  };\n\n  return (\n    &lt;div className="space-x-2"&gt;\n      &lt;button className="px-4 py-2 bg-gray-600 text-white rounded" onClick={(e) => handleButtonClick('Home', e)}&gt;Home&lt;/button&gt;\n      &lt;button className="px-4 py-2 bg-gray-600 text-white rounded" onClick={(e) => handleButtonClick('About', e)}&gt;About&lt;/button&gt;\n      &lt;button className="px-4 py-2 bg-gray-600 text-white rounded" onClick={(e) => handleButtonClick('Contact', e)}&gt;Contact&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><p>เมื่อกดปุ่ม ข้อมูลจะถูก log ไว้ใน console ของเบราว์เซอร์ (กด F12 เพื่อดู)</p></div>`,
                16: `<h2 class="text-3xl font-bold mb-4">useEffect Hook - Introduction</h2><p class="mb-4 text-lg"><code>useEffect</code> ใช้สำหรับจัดการ <b>side effects</b> ใน function components. Side effects คือการทำงานใดๆ ที่อยู่นอกเหนือการ render UI เช่น การเรียก API, การอัปเดต DOM โดยตรง, หรือการตั้งค่า subscription.</p><p class="mb-4">โดย default แล้ว, effect จะทำงาน<b>หลังจากทุกครั้งที่ component render เสร็จ</b></p><pre class="code-block">import { useState, useEffect } from 'react';\n\nfunction DocumentTitleUpdater() {\n  const [count, setCount] = useState(0);\n\n  // Effect นี้จะทำงานหลังจากทุกครั้งที่ render\n  useEffect(() => {\n    document.title = \`You clicked \\\${count} times\`;\n    console.log('Document title updated!');\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={() => setCount(count + 1)}&gt;\n        Click me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><p>เมื่อกดปุ่ม "Click me" ค่า count จะเพิ่มขึ้น และ title ของ browser tab จะเปลี่ยนตามไปด้วย</p></div>`,
                17: `<h2 class="text-3xl font-bold mb-4">useEffect Dependencies</h2><p class="mb-4 text-lg">เราสามารถควบคุมได้ว่า effect จะทำงานเมื่อไหร่ โดยการใส่ <b>dependency array</b> เป็น argument ที่สองของ <code>useEffect</code></p><h3 class="text-xl font-semibold mb-2">รันครั้งเดียว (เหมือน ComponentDidMount)</h3><p class="mb-2">ใส่ array ว่าง <code>[]</code> เพื่อให้ effect ทำงานแค่ครั้งเดียวหลังจาก component ถูก mount (render ครั้งแรก) เหมาะสำหรับการเรียก API หรือตั้งค่าเริ่มต้น</p><pre class="code-block">useEffect(() => {\n  console.log('Component mounted! This runs only once.');\n}, []); // &lt;-- Empty dependency array</pre><h3 class="text-xl font-semibold mt-6 mb-2">รันเมื่อค่าใน dependency เปลี่ยน</h3><p class="mb-2">ใส่ state หรือ props ที่ต้องการเฝ้าดูลงใน array. Effect จะทำงานอีกครั้งก็ต่อเมื่อค่าเหล่านั้นมีการเปลี่ยนแปลง</p><pre class="code-block">function Watcher() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n\n  // Effect นี้จะรันเมื่อ 'count' เปลี่ยนเท่านั้น\n  useEffect(() => {\n    console.log(\`Count has changed to: \\\${count}\`);\n  }, [count]);\n\n  return (\n    &lt;div className="space-y-4"&gt;\n      &lt;button onClick={() => setCount(c => c + 1)}&gt;Count is {count}&lt;/button&gt;\n      &lt;input value={name} onChange={e => setName(e.target.value)} placeholder="Changing this won't trigger effect" /&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><p>ในตัวอย่างที่สอง console log จะปรากฏขึ้นเมื่อกดปุ่ม "Count" เท่านั้น แต่จะไม่ปรากฏเมื่อพิมพ์ในช่อง input</p></div>`,
                18: `<h2 class="text-3xl font-bold mb-4">useEffect Cleanup</h2><p class="mb-4 text-lg">บาง side effect จำเป็นต้องมีการ "ทำความสะอาด" (cleanup) เมื่อ component จะ unmount (ถูกเอาออกจาก DOM) เพื่อป้องกัน memory leaks เช่น การยกเลิก timer หรือการลบ event listener</p><p class="mb-4">เราสามารถทำได้โดยการ <b>return function</b> จาก <code>useEffect</code> ซึ่ง function นี้จะถูกเรียกก่อนที่ component จะ unmount หรือก่อนที่ effect จะรันอีกครั้ง</p><h3 class="text-xl font-semibold mb-2">ตัวอย่าง: Cleanup Timer</h3><pre class="code-block">function Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setSeconds(prev => prev + 1);\n    }, 1000);\n\n    // Cleanup function: จะถูกเรียกเมื่อ component unmount\n    return () => {\n      clearInterval(intervalId);\n      console.log('Timer cleaned up!');\n    };\n  }, []);\n\n  return &lt;div&gt;Timer: {seconds} seconds&lt;/div&gt;;\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><p>Timer จะนับไปเรื่อยๆ และเมื่อ component นี้หายไป (เช่น เปลี่ยนหน้า) timer จะหยุดทำงาน และ console จะแสดง "Timer cleaned up!"</p></div>`,
                19: `<h2 class="text-3xl font-bold mb-4">Fetching Data with useEffect</h2><p class="mb-4 text-lg">Pattern ที่นิยมใช้ในการดึงข้อมูลจาก API คือการใช้ <code>useEffect</code> ร่วมกับ <code>useState</code> เพื่อเก็บสถานะต่างๆ (data, loading, error)</p><pre class="code-block">function UserList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchUsers = async () => {\n      try {\n        const response = await fetch('https://jsonplaceholder.typicode.com/users');\n        if (!response.ok) {\n          throw new Error('Failed to fetch data');\n        }\n        const data = await response.json();\n        setUsers(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUsers();\n  }, []); // รันแค่ครั้งเดียวตอน mount\n\n  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;\n  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;\n\n  return (\n    &lt;ul&gt;\n      {users.map(user => (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์ (Mockup):</h4><div class="space-y-4"><div class="p-4 bg-yellow-100 rounded-lg"><b>Loading State:</b><p>Loading...</p></div><div class="p-4 bg-red-100 rounded-lg"><b>Error State:</b><p>Error: Failed to fetch data</p></div><div class="p-4 bg-green-100 rounded-lg"><b>Success State:</b><ul class="list-disc list-inside"><li>Leanne Graham</li><li>Ervin Howell</li><li>...and more</li></ul></div></div></div>`,
                20: `<h2 class="text-3xl font-bold mb-4">useContext Hook - Introduction</h2><p class="mb-4 text-lg"><b>Context API</b> ช่วยแก้ปัญหา <b>"prop drilling"</b> ซึ่งคือการที่เราต้องส่ง props ผ่าน component หลายๆ ชั้น ทั้งๆ ที่ component ตรงกลางไม่ได้ใช้ props นั้นเลย Context ทำให้เราสามารถส่งข้อมูลไปยัง component ใดๆ ใน tree ได้โดยตรง</p><h3 class="text-xl font-semibold mb-2">ขั้นตอนที่ 1: สร้าง Context</h3><p class="mb-2">ใช้ <code>createContext</code> เพื่อสร้าง context object. เราสามารถใส่ค่าเริ่มต้นได้</p><pre class="code-block">// contexts/ThemeContext.js\nimport { createContext } from 'react';\n\n// สร้าง Context และ export ออกไป\nexport const ThemeContext = createContext('light'); // 'light' is the default value</pre><h3 class="text-xl font-semibold mt-6 mb-2">ขั้นตอนที่ 2: สร้าง Provider</h3><p class="mb-2">Provider เป็น component ที่จะ "ส่ง" ค่า context ให้กับ component ลูกทั้งหมดที่อยู่ภายใต้มัน</p><pre class="code-block">// contexts/ThemeProvider.js\nimport { useState } from 'react';\nimport { ThemeContext } from './ThemeContext';\n\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () => {\n    setTheme(prev => (prev === 'light' ? 'dark' : 'light'));\n  };\n\n  // ค่าที่จะส่งลงไปใน context\n  const value = { theme, toggleTheme };\n\n  return (\n    &lt;ThemeContext.Provider value={value}&gt;\n      {children}\n    &lt;/ThemeContext.Provider&gt;\n  );\n}</pre><div class="result-block"><p>ในสไลด์ถัดไป เราจะดูวิธีนำ Provider ไปใช้และวิธีดึงค่าจาก Context ใน component ลูก</p></div>`,
                21: `<h2 class="text-3xl font-bold mb-4">Using Context</h2><h3 class="text-xl font-semibold mb-2">ขั้นตอนที่ 3: ครอบ App ด้วย Provider</h3><p class="mb-2">นำ Provider ที่สร้างไว้ไปครอบ component ระดับบนสุด (เช่น App.jsx หรือ main.jsx) เพื่อให้ทุก component ที่อยู่ข้างในสามารถเข้าถึง context ได้</p><pre class="code-block">// App.jsx\nimport { ThemeProvider } from './contexts/ThemeProvider';\nimport PageLayout from './components/PageLayout';\n\nfunction App() {\n  return (\n    &lt;ThemeProvider&gt;\n      &lt;PageLayout /&gt;\n    &lt;/ThemeProvider&gt;\n  );\n}</pre><h3 class="text-xl font-semibold mt-6 mb-2">ขั้นตอนที่ 4: เรียกใช้ Context ด้วย <code>useContext</code></h3><p class="mb-2">ใน component ลูกที่ต้องการใช้ข้อมูล ให้ import <code>useContext</code> และ context object เข้ามา แล้วเรียกใช้เพื่อดึงค่า</p><pre class="code-block">// components/PageLayout.jsx\nimport { useContext } from 'react';\nimport { ThemeContext } from '../contexts/ThemeContext';\n\nfunction PageLayout() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    &lt;div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}&gt;\n      &lt;h1&gt;Current Theme: {theme}&lt;/h1&gt;\n      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</pre><div id="context-app" class="result-block"></div>`,
                22: `<h2 class="text-3xl font-bold mb-4">Component Composition</h2><p class="mb-4 text-lg">React สนับสนุนแนวคิด <b>Composition over Inheritance</b> หมายความว่าเราจะสร้าง component ที่ซับซ้อนขึ้นมาโดยการนำ component เล็กๆ มาประกอบกัน แทนที่จะใช้การสืบทอดคุณสมบัติ (inheritance) แบบใน OOP</p><h3 class="text-xl font-semibold mb-2">การใช้ <code>children</code> Prop</h3><p class="mb-2"><code>props.children</code> เป็น prop พิเศษที่เก็บ element ทั้งหมดที่ถูกส่งเข้ามาอยู่ระหว่าง tag เปิดและปิดของ component ทำให้เราสร้าง component ที่เป็น "กล่อง" หรือ "wrapper" ได้</p><pre class="code-block">// Generic Card component\nfunction Card({ children, title }) {\n  return (\n    &lt;div className="border rounded-lg shadow-md p-4"&gt;\n      &lt;h3 className="text-xl font-bold mb-2 border-b pb-2"&gt;{title}&lt;/h3&gt;\n      &lt;div className="mt-2"&gt;\n        {children} &lt;!-- Render anything passed inside --&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\n// การใช้งาน\nfunction App() {\n  return (\n    &lt;Card title="User Info"&gt;\n      &lt;p&gt;Name: John Doe&lt;/p&gt;\n      &lt;p&gt;Email: john@example.com&lt;/p&gt;\n      &lt;button className="mt-2 px-3 py-1 bg-blue-500 text-white rounded"&gt;Edit&lt;/button&gt;\n    &lt;/Card&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><div class="border rounded-lg shadow-md p-4"><h3 class="text-xl font-bold mb-2 border-b pb-2">User Info</h3><div class="mt-2"><p>Name: John Doe</p><p>Email: john@example.com</p><button class="mt-2 px-3 py-1 bg-blue-500 text-white rounded">Edit</button></div></div></div>`,
                23: `<h2 class="text-3xl font-bold mb-4">Conditional Rendering</h2><p class="mb-4 text-lg">เราสามารถแสดงผล UI ที่แตกต่างกันตามเงื่อนไขหรือ state ได้หลายวิธี</p><h3 class="text-xl font-semibold mb-2">1. Ternary Operator (<code>? :</code>)</h3><p class="mb-2">เป็นวิธีที่นิยมใช้สำหรับการสลับไปมาระหว่าง UI สองแบบ (if/else)</p><pre class="code-block">function UserStatus({ isLoggedIn }) {\n  return (\n    &lt;div&gt;\n      {isLoggedIn ? (\n        &lt;p&gt;Welcome back, User!&lt;/p&gt;\n      ) : (\n        &lt;p&gt;Please log in.&lt;/p&gt;\n      )}\n    &lt;/div&gt;\n  );\n}</pre><div id="conditional-app-1" class="result-block"></div><h3 class="text-xl font-semibold mt-6 mb-2">2. Logical AND (<code>&&</code>) Operator</h3><p class="mb-2">เหมาะสำหรับกรณีที่ต้องการแสดงผลบางอย่าง "ถ้า" เงื่อนไขเป็นจริงเท่านั้น (if without else)</p><pre class="code-block">function Mailbox({ unreadMessages }) {\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Inbox&lt;/h2&gt;\n      {unreadMessages.length > 0 &&\n        &lt;h3&gt;You have {unreadMessages.length} unread messages.&lt;/h3&gt;\n      }\n    &lt;/div&gt;\n  );\n}</pre><div id="conditional-app-2" class="result-block"></div>`,
                24: `<h2 class="text-3xl font-bold mb-4">Lists and Keys</h2><p class="mb-4 text-lg">เราใช้ฟังก์ชัน <code>.map()</code> ของ array เพื่อแปลงข้อมูลแต่ละตัวใน list ให้กลายเป็น React element</p><h3 class="text-xl font-semibold mb-2">ความสำคัญของ "Keys"</h3><p class="mb-2"><b>Key</b> เป็น prop พิเศษที่เราต้องใส่ให้กับทุก element ใน list. React ใช้ key เพื่อระบุว่า item ไหนมีการเปลี่ยนแปลง, เพิ่ม, หรือลบไป. Key ช่วยให้ React อัปเดต UI ได้อย่างมีประสิทธิภาพ</p><ul class="list-disc list-inside space-y-1 mb-4"><li>Key ต้องเป็น <b>string หรือ number ที่ไม่ซ้ำกัน</b> ภายใน list นั้นๆ</li><li>ควรใช้ ID ที่มีความเสถียรจากข้อมูล (เช่น <code>product.id</code>)</li><li><b>ไม่ควรใช้ index ของ array เป็น key</b> หาก list นั้นสามารถมีการเรียงลำดับใหม่, เพิ่ม, หรือลบ item ตรงกลางได้ เพราะอาจทำให้เกิด bug และ performance ที่ไม่ดี</li></ul><pre class="code-block">function ProductList({ products }) {\n  return (\n    &lt;ul&gt;\n      {products.map(product => (\n        // ✅ Good: ใช้ ID ที่ไม่ซ้ำกันจากข้อมูล\n        &lt;li key={product.id} className="p-2 border-b"&gt;\n          {product.name} - \\\${product.price}\n        &lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n\nconst products = [\n  { id: 'p1', name: 'Laptop', price: 1200 },\n  { id: 'p2', name: 'Mouse', price: 25 },\n  { id: 'p3', name: 'Keyboard', price: 75 },\n];</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><ul class="list-disc list-inside"><li class="p-2 border-b">Laptop - $1200</li><li class="p-2 border-b">Mouse - $25</li><li class="p-2">Keyboard - $75</li></ul></div>`,
                25: `<h2 class="text-3xl font-bold mb-4">Forms in React (Controlled Components)</h2><p class="mb-4 text-lg">ใน React, <b>Controlled Component</b> คือ form element (เช่น <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>) ที่ค่าของมันถูกควบคุมโดย React state. ข้อมูลที่ผู้ใช้กรอกจะถูกเก็บไว้ใน state และ state จะเป็น "single source of truth"</p><pre class="code-block">function ContactForm() {\n  const [name, setName] = useState('');\n\n  const handleChange = (e) => {\n    setName(e.target.value);\n  };\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    alert(\`Hello, \\\${name}!\`);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;\n      &lt;input\n        id="name"\n        className="form-input"\n        value={name} // ค่าของ input ผูกกับ state\n        onChange={handleChange} // ทุกการเปลี่ยนแปลงจะอัปเดต state\n      />\n      &lt;button type="submit" className="mt-2 px-4 py-2 bg-blue-500 text-white rounded"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}</pre><div id="form-app" class="result-block"></div>`,
                26: `<h2 class="text-3xl font-bold mb-4">Form Validation</h2><p class="mb-4 text-lg">เราสามารถเพิ่มการตรวจสอบความถูกต้องของข้อมูล (validation) ได้โดยการสร้าง state สำหรับเก็บ error messages และสร้างฟังก์ชันสำหรับตรวจสอบข้อมูลก่อน submit</p><pre class="code-block">function SignupForm() {\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (password.length < 8) {\n      setError('Password must be at least 8 characters long.');\n    } else if (!email.includes('@')) {\n      setError('Please enter a valid email.');\n    } else {\n      setError('');\n      alert('Form submitted successfully!');\n    }\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit} className="space-y-4"&gt;\n      &lt;input type="email" value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" /&gt;\n      &lt;input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Password" /&gt;\n      {error && &lt;p className="error"&gt;{error}&lt;/p&gt;}\n      &lt;button type="submit"&gt;Sign Up&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}</pre><div id="validation-form-app" class="result-block"></div>`,
                27: `<h2 class="text-3xl font-bold mb-4">Component Design Patterns</h2><h3 class="text-xl font-semibold mb-2">Container/Presentational Pattern</h3><p class="mb-4 text-lg">เป็น pattern ที่แยก component ออกเป็น 2 ประเภทเพื่อจัดการ logic และ UI ให้เป็นสัดส่วน:</p><ul class="list-disc list-inside space-y-2 mb-4"><li><b>Container Components:</b> ดูแลเรื่อง "How things work". มีหน้าที่จัดการ state, เรียก API, และส่งข้อมูล/ฟังก์ชันลงไปให้ Presentational component ผ่าน props.</li><li><b>Presentational Components:</b> ดูแลเรื่อง "How things look". รับข้อมูลผ่าน props และแสดงผล UI เท่านั้น. ไม่มี state ของตัวเอง และไม่ยุ่งกับ logic ที่ซับซ้อน.</li></ul><pre class="code-block">// Presentational Component (Dumb)\nfunction UserListView({ users, onUserSelect }) {\n  return (\n    &lt;ul&gt;{users.map(user => (&lt;li key={user.id} onClick={() => onUserSelect(user)}&gt;{user.name}&lt;/li&gt;))}&lt;/ul&gt;\n  );\n}\n\n// Container Component (Smart)\nfunction UserListContainer() {\n  const [users, setUsers] = useState([]);\n  useEffect(() => { /* fetch users from API and setUsers */ }, []);\n  const handleUserSelect = (user) => console.log('Selected:', user.name);\n  \n  return &lt;UserListView users={users} onUserSelect={handleUserSelect} /&gt;;\n}</pre><div class="result-block"><p><b>ข้อดี:</b> ทำให้โค้ดอ่านง่าย, นำ Presentational component ไปใช้ซ้ำได้สะดวก, และง่ายต่อการทดสอบ.</p></div>`,
                28: `<h2 class="text-3xl font-bold mb-4">Higher-Order Components (HOC)</h2><p class="mb-4 text-lg">HOC เป็น pattern ขั้นสูงใน React. มันคือ<b>ฟังก์ชัน</b>ที่รับ component เข้ามา และ return component ใหม่ที่เสริมความสามารถเข้าไป.</p><p class="mb-4">HOC เป็นวิธีหนึ่งในการใช้ logic ซ้ำๆ ระหว่าง component หลายๆ ตัว เช่น การตรวจสอบสิทธิ์ (authentication) หรือการแสดงสถานะ loading.</p><pre class="code-block">// HOC for adding a loading spinner\nfunction withLoading(WrappedComponent) {\n  return function WithLoadingComponent({ isLoading, ...props }) {\n    if (isLoading) {\n      return &lt;div&gt;Loading...&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n}\n\n// A simple component that displays data\nfunction UserList({ users }) { /* ... renders a list of users ... */ }\n\n// Enhance UserList with the HOC\nconst UserListWithLoading = withLoading(UserList);\n\n// Usage in another component\nfunction App() {\n  const [loading, setLoading] = useState(true);\n  const [users, setUsers] = useState([]);\n  // ... fetch users and eventually call setLoading(false) ...\n  \n  return &lt;UserListWithLoading isLoading={loading} users={users} /&gt;;\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><p>เมื่อ <code>isLoading</code> เป็น <code>true</code>, หน้าจอจะแสดง "Loading...". เมื่อเป็น <code>false</code>, <code>UserList</code> component จะถูก render ตามปกติ.</p><p class="mt-2 text-sm text-gray-600"><b>Note:</b> ปัจจุบัน Custom Hooks เป็นที่นิยมมากกว่า HOC สำหรับการใช้ logic ซ้ำ แต่ HOC ยังคงมีประโยชน์ในบางกรณี</p></div>`,
                29: `<h2 class="text-3xl font-bold mb-4">Custom Hooks</h2><p class="mb-4 text-lg">Custom Hook คือฟังก์ชัน JavaScript ที่ชื่อขึ้นต้นด้วย <code>use</code> และสามารถเรียกใช้ Hooks อื่นๆ ของ React ได้ (เช่น <code>useState</code>, <code>useEffect</code>). เป็นวิธีที่ทันสมัยและนิยมที่สุดในการแยก component logic ออกมาเพื่อให้สามารถนำไปใช้ซ้ำได้</p><h3 class="text-xl font-semibold mb-2">ตัวอย่าง: <code>useCounter</code></h3><pre class="code-block">// hooks/useCounter.js\nimport { useState } from 'react';\n\nexport function useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n  \n  const increment = () => setCount(prev => prev + 1);\n  const decrement = () => setCount(prev => prev - 1);\n  \n  return { count, increment, decrement };\n}\n\n// การใช้งานใน Component\nfunction CounterComponent() {\n  const { count, increment, decrement } = useCounter(10);\n  \n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;+&lt;/button&gt;\n      &lt;button onClick={decrement}&gt;-&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</pre><div class="result-block"><h4 class="font-bold mb-2">ผลลัพธ์:</h4><p>จะแสดง Counter ที่เริ่มต้นที่ 10 และสามารถเพิ่มลดค่าได้ โดย logic ทั้งหมดถูกเก็บไว้ใน <code>useCounter</code> hook</p></div>`,
                30: `<h2 class="text-3xl font-bold mb-4">Performance Optimization Basics</h2><p class="mb-4 text-lg">เมื่อแอปพลิเคชันมีความซับซ้อน การ re-render ที่ไม่จำเป็นอาจทำให้ประสิทธิภาพลดลง React มีเครื่องมือช่วยป้องกันปัญหานี้</p><h3 class="text-xl font-semibold mb-2"><code>React.memo</code></h3><p class="mb-2">เป็น HOC ที่ป้องกันไม่ให้ component re-render หาก props ที่ส่งเข้ามาไม่มีการเปลี่ยนแปลง. เหมาะสำหรับ component ที่ render บ่อยแต่ props เปลี่ยนไม่บ่อย</p><pre class="code-block">const MyComponent = React.memo(function MyComponent(props) {\n  /* re-renders only when its props change */\n});</pre><h3 class="text-xl font-semibold mt-6 mb-2"><code>useMemo</code></h3><p class="mb-2">เป็น Hook ที่ใช้ "memoize" (จำ) ผลลัพธ์ของการคำนวณที่ซับซ้อน. ฟังก์ชันคำนวณจะทำงานอีกครั้งก็ต่อเมื่อค่าใน dependency array เปลี่ยนไปเท่านั้น</p><pre class="code-block">const expensiveValue = useMemo(() => {\n  return computeExpensiveValue(a, b);\n}, [a, b]); // Recalculates only if a or b changes</pre><h3 class="text-xl font-semibold mt-6 mb-2"><code>useCallback</code></h3><p class="mb-2">เป็น Hook ที่ใช้ "memoize" ตัวฟังก์ชันเอง. ช่วยป้องกันไม่ให้ component ลูก re-render โดยไม่จำเป็นเมื่อเราส่งฟังก์ชันนั้นลงไปเป็น prop</p><pre class="code-block">const memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]); // The function reference is stable if a and b don't change</pre>`,
                35: `<h2 class="text-3xl font-bold mb-4">Summary and Next Steps</h2><h3 class="text-xl font-semibold mb-2">สิ่งที่เรียนรู้วันนี้</h3><ul class="list-disc list-inside space-y-2 mb-6 text-lg"><li>✅ <b>React Fundamentals:</b> JSX, Components, Props, Composition</li><li>✅ <b>State Management:</b> การใช้ <code>useState</code> กับ data type ต่างๆ</li><li>✅ <b>Side Effects:</b> การใช้ <code>useEffect</code> สำหรับ data fetching และ cleanup</li><li>✅ <b>Global State:</b> การใช้ <code>useContext</code> เพื่อหลีกเลี่ยง prop drilling</li><li>✅ <b>Best Practices:</b> Component patterns, form handling, project structure</li></ul><h3 class="text-xl font-semibold mb-2">Next Steps สำหรับการเรียนรู้ต่อ</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6"><div class="bg-blue-50 p-4 rounded-lg"><b>Routing:</b> React Router DOM</div><div class="bg-blue-50 p-4 rounded-lg"><b>Advanced State Management:</b> Zustand, Redux Toolkit</div><div class="bg-blue-50 p-4 rounded-lg"><b>Testing:</b> Jest, React Testing Library</div><div class="bg-blue-50 p-4 rounded-lg"><b>Styling:</b> Styled Components, Tailwind CSS</div><div class="bg-blue-50 p-4 rounded-lg"><b>Component Libraries:</b> Material-UI, Ant Design</div><div class="bg-blue-50 p-4 rounded-lg"><b>Deployment:</b> Vercel, Netlify</div></div><h3 class="text-xl font-semibold mb-2">การบ้าน</h3><div class="bg-green-100 border-l-4 border-green-500 text-green-800 p-4 rounded-r-lg"><p class="font-bold">สร้าง Personal Portfolio Website ด้วย React</p><p>ให้มี component อย่างน้อยดังนี้: Header, About Section, Projects List, และ Contact Form. (Bonus: เพิ่ม Theme switcher โดยใช้ Context API)</p></div>`
            };
            
            // --- Helper functions for interactive mockups ---
            const createInteractiveCounter = (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                let count = 0;
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div class="text-center border p-4 rounded-lg bg-white">
                            <h2 class="text-4xl font-bold mb-4">${count}</h2>
                            <div class="space-x-2">
                                <button data-action="inc" class="px-4 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 transition">Increase</button>
                                <button data-action="dec" class="px-4 py-2 bg-yellow-500 text-white rounded-lg shadow hover:bg-yellow-600 transition">Decrease</button>
                                <button data-action="reset" class="px-4 py-2 bg-red-500 text-white rounded-lg shadow hover:bg-red-600 transition">Reset</button>
                            </div>
                        </div>
                    `;
                };
                container.addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    if (action === 'inc') count++;
                    if (action === 'dec') count--;
                    if (action === 'reset') count = 0;
                    render();
                });
                render();
            };

            const createInteractiveNameInput = (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                let name = '';
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div class="border p-4 rounded-lg bg-white">
                            <input type="text" class="form-input" value="${name}" placeholder="Enter your name" />
                            <p class="mt-2 text-lg">Hello, ${name || 'stranger'}!</p>
                        </div>
                    `;
                };
                container.addEventListener('input', (e) => {
                    if (e.target.tagName === 'INPUT') {
                        name = e.target.value;
                        render();
                        const newInp = container.querySelector('input');
                        newInp.focus();
                        newInp.setSelectionRange(name.length, name.length);
                    }
                });
                render();
            };
            
            const createInteractiveToggle = (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                let isVisible = true;
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div class="border p-4 rounded-lg bg-white">
                            <button class="px-4 py-2 bg-indigo-500 text-white rounded-lg shadow hover:bg-indigo-600 transition">
                                ${isVisible ? 'Hide' : 'Show'} Message
                            </button>
                            ${isVisible ? `<p class="mt-4 p-4 bg-indigo-100 text-indigo-800 rounded-lg">This message can be toggled!</p>` : ''}
                        </div>
                    `;
                };
                container.addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        isVisible = !isVisible;
                        render();
                    }
                });
                render();
            };

            const createInteractiveObjectState = (containerId) => {
                const container = document.getElementById(containerId);
                if(!container) return;
                let user = { name: '', email: '' };
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div class="border p-4 rounded-lg bg-white space-y-4">
                            <div>
                                <label class="font-medium">Name:</label>
                                <input data-field="name" type="text" class="form-input" value="${user.name}" placeholder="Enter name" />
                            </div>
                            <div>
                                <label class="font-medium">Email:</label>
                                <input data-field="email" type="email" class="form-input" value="${user.email}" placeholder="Enter email" />
                            </div>
                            <div class="p-4 bg-gray-100 rounded-lg">
                                <p><b>Current State:</b></p>
                                <pre class="text-sm">{\n  name: "${user.name}",\n  email: "${user.email}"\n}</pre>
                            </div>
                        </div>
                    `;
                }
                container.addEventListener('input', e => {
                    if(e.target.tagName === 'INPUT') {
                        user = {...user, [e.target.dataset.field]: e.target.value };
                        render();
                        const newInp = container.querySelector(`[data-field="${e.target.dataset.field}"]`);
                        newInp.focus();
                        newInp.setSelectionRange(e.target.value.length, e.target.value.length);
                    }
                });
                render();
            };

            const createInteractiveArrayState = (containerId) => {
                const container = document.getElementById(containerId);
                if(!container) return;
                let todos = [
                    { id: 1, text: 'Learn React', completed: true },
                    { id: 2, text: 'Build a project', completed: false }
                ];
                let inputValue = '';

                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div class="border p-4 rounded-lg bg-white">
                            <div class="flex gap-2 mb-4">
                                <input type="text" class="form-input flex-grow" value="${inputValue}" placeholder="Add a new todo" />
                                <button data-action="add" class="px-4 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 transition">Add</button>
                            </div>
                            <ul class="space-y-2">
                                ${todos.map(todo => `
                                    <li class="flex items-center gap-3 p-2 rounded-lg ${todo.completed ? 'bg-gray-100' : ''}">
                                        <input type="checkbox" ${todo.completed ? 'checked' : ''} data-action="toggle" data-id="${todo.id}" class="h-5 w-5 rounded text-blue-500 focus:ring-blue-500" />
                                        <span class="flex-grow ${todo.completed ? 'line-through text-gray-500' : ''}">${todo.text}</span>
                                        <button data-action="remove" data-id="${todo.id}" class="text-red-500 hover:text-red-700 font-bold">X</button>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    `;
                }

                container.addEventListener('input', e => {
                    if(e.target.tagName === 'INPUT' && e.target.type === 'text') {
                        inputValue = e.target.value;
                    }
                });

                container.addEventListener('click', e => {
                    const action = e.target.dataset.action;
                    if (action === 'add' && inputValue.trim()) {
                        todos = [...todos, { id: Date.now(), text: inputValue.trim(), completed: false }];
                        inputValue = '';
                    }
                    if (action === 'remove') {
                        todos = todos.filter(t => t.id !== Number(e.target.dataset.id));
                    }
                    if (action === 'toggle') {
                        todos = todos.map(t => t.id === Number(e.target.dataset.id) ? {...t, completed: !t.completed} : t);
                    }
                    render();
                    if(action === 'add') {
                        container.querySelector('input[type="text"]').focus();
                    }
                });

                render();
            };

            const createInteractiveEventHandling = (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                let message = 'No event yet.';
                let inputValue = '';
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <form class="space-y-4 border p-4 rounded-lg bg-white">
                            <div class="space-x-2">
                                <button type="button" data-action="click" class="px-4 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 transition">Click Me</button>
                                <button type="submit" data-action="submit" class="px-4 py-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 transition">Submit</button>
                            </div>
                            <div>
                                <input type="text" class="form-input" value="${inputValue}" placeholder="Type something..." />
                            </div>
                            <p class="p-4 bg-gray-100 rounded-lg min-h-[50px]"><b>Status:</b> ${message}</p>
                        </form>
                    `;
                };

                container.addEventListener('click', e => {
                    e.preventDefault();
                    const action = e.target.dataset.action;
                    if (action === 'click') {
                        message = 'Button was clicked!';
                        render();
                    }
                    if (action === 'submit') {
                        alert('Form submitted!');
                        message = `Form submitted with input: "${inputValue}"`;
                        render();
                    }
                });

                container.addEventListener('input', e => {
                    if (e.target.tagName === 'INPUT') {
                        inputValue = e.target.value;
                        message = `Input value: ${inputValue}`;
                        render();
                        const newInp = container.querySelector('input');
                        newInp.focus();
                        newInp.setSelectionRange(inputValue.length, inputValue.length);
                    }
                });

                render();
            };

            const createInteractiveContext = (containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                let theme = 'light';
                const render = () => {
                    const isLight = theme === 'light';
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <div class="border p-4 rounded-lg transition-colors duration-300" style="background: ${isLight ? '#fff' : '#1a202c'}; color: ${isLight ? '#1a202c' : '#e2e8f0'};">
                            <h2 class="text-2xl font-bold">Current Theme: ${theme}</h2>
                            <p>This component consumes the theme from context.</p>
                            <button class="mt-4 px-4 py-2 rounded-lg shadow transition" style="background: ${isLight ? '#333' : '#fff'}; color: ${isLight ? '#fff' : '#333'};">
                                Switch to ${isLight ? 'Dark' : 'Light'}
                            </button>
                        </div>
                    `;
                };
                container.addEventListener('click', e => {
                    if(e.target.tagName === 'BUTTON') {
                        theme = theme === 'light' ? 'dark' : 'light';
                        render();
                    }
                });
                render();
            };
            
            const createInteractiveConditional = (containerId1, containerId2) => {
                const container1 = document.getElementById(containerId1);
                const container2 = document.getElementById(containerId2);
                if(!container1 || !container2) return;

                let isLoggedIn = false;
                let messages = 3;

                const render1 = () => {
                    container1.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Ternary):</h4>
                        <div class="border p-4 rounded-lg bg-white flex items-center justify-between">
                            <p class="text-lg">${isLoggedIn ? '<span class="text-green-600">Welcome back, User!</span>' : '<span class="text-red-600">Please log in.</span>'}</p>
                            <button class="px-3 py-1 text-sm rounded-md text-white ${isLoggedIn ? 'bg-red-500' : 'bg-green-500'}">${isLoggedIn ? 'Logout' : 'Login'}</button>
                        </div>
                    `;
                };

                 const render2 = () => {
                    container2.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Logical AND):</h4>
                        <div class="border p-4 rounded-lg bg-white">
                            <h2 class="text-xl font-bold">Inbox</h2>
                            ${messages > 0 ? `<h3 class="mt-2 text-blue-600">You have ${messages} unread messages.</h3>` : '<p class="mt-2 text-gray-500">No new messages.</p>'}
                             <div class="mt-4 space-x-2">
                                <button data-action="add" class="px-3 py-1 text-sm rounded-md bg-blue-500 text-white">Add Message</button>
                                <button data-action="clear" class="px-3 py-1 text-sm rounded-md bg-gray-500 text-white">Clear Messages</button>
                            </div>
                        </div>
                    `;
                };

                container1.addEventListener('click', e => {
                    if(e.target.tagName === 'BUTTON') {
                        isLoggedIn = !isLoggedIn;
                        render1();
                    }
                });
                 container2.addEventListener('click', e => {
                    if(e.target.tagName === 'BUTTON') {
                        if(e.target.dataset.action === 'add') messages++;
                        if(e.target.dataset.action === 'clear') messages = 0;
                        render2();
                    }
                });

                render1();
                render2();
            };

            const createInteractiveForm = (containerId) => {
                const container = document.getElementById(containerId);
                if(!container) return;
                let name = '';
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <form class="border p-4 rounded-lg bg-white space-y-3">
                            <div>
                                <label for="name-form" class="font-medium">Name:</label>
                                <input id="name-form" class="form-input mt-1" value="${name}" />
                            </div>
                            <button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 transition">Submit</button>
                        </form>
                    `;
                };
                 container.addEventListener('input', e => {
                    if(e.target.id === 'name-form') {
                        name = e.target.value;
                    }
                });
                container.addEventListener('submit', e => {
                    e.preventDefault();
                    alert(`Hello, ${name || 'stranger'}!`);
                });
                render();
            };

            const createInteractiveValidationForm = (containerId) => {
                const container = document.getElementById(containerId);
                if(!container) return;
                let email = '';
                let password = '';
                let error = '';
                const render = () => {
                    container.innerHTML = `
                        <h4 class="font-bold mb-2">ผลลัพธ์ (Interactive Mockup):</h4>
                        <form class="border p-4 rounded-lg bg-white space-y-4">
                            <div>
                                <input type="email" class="form-input" value="${email}" placeholder="Email" />
                            </div>
                            <div>
                                <input type="password" class="form-input" value="${password}" placeholder="Password" />
                            </div>
                            ${error ? `<p class="error">${error}</p>` : ''}
                            <button type="submit" class="px-4 py-2 bg-purple-500 text-white rounded-lg shadow hover:bg-purple-600 transition">Sign Up</button>
                        </form>
                    `;
                };
                container.addEventListener('input', e => {
                    if(e.target.type === 'email') email = e.target.value;
                    if(e.target.type === 'password') password = e.target.value;
                });
                container.addEventListener('submit', e => {
                    e.preventDefault();
                    if (password.length < 8) {
                        error = 'Password must be at least 8 characters long.';
                    } else if (!email.includes('@')) {
                        error = 'Please enter a valid email.';
                    } else {
                        error = '';
                        alert('Form submitted successfully!');
                    }
                    render();
                });
                render();
            };

            // --- Main script ---
            const sidebarNav = document.getElementById('sidebar-nav');
            const mainContent = document.getElementById('main-content');

            // Generate sidebar links and content sections
            slides.forEach((slide) => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#slide-${slide.id}`;
                a.textContent = `${slide.id}. ${slide.title}`;
                a.classList.add('sidebar-link', 'block', 'p-2', 'rounded-md', 'text-gray-700');
                a.dataset.target = `slide-${slide.id}`;
                li.appendChild(a);
                sidebarNav.appendChild(li);

                const section = document.createElement('div');
                section.id = `slide-${slide.id}`;
                section.classList.add('content-section', 'bg-white', 'p-6', 'rounded-lg', 'shadow');
                section.innerHTML = content[slide.id] || `<h2 class="text-3xl font-bold mb-4">${slide.title}</h2><p>เนื้อหาสำหรับส่วนนี้กำลังเตรียมการ</p>`;
                mainContent.appendChild(section);
            });

            // Activate interactive mockups after they are in the DOM
            createInteractiveCounter('counter-app');
            createInteractiveNameInput('name-input-app');
            createInteractiveToggle('toggle-app');
            createInteractiveObjectState('object-state-app');
            createInteractiveArrayState('array-state-app');
            createInteractiveEventHandling('event-handling-app');
            createInteractiveContext('context-app');
            createInteractiveConditional('conditional-app-1', 'conditional-app-2');
            createInteractiveForm('form-app');
            createInteractiveValidationForm('validation-form-app');

            const sidebarLinks = document.querySelectorAll('.sidebar-link');
            const contentSections = document.querySelectorAll('.content-section');

            function showContent(targetId) {
                let found = false;
                contentSections.forEach(section => {
                    if (section.id === targetId) {
                        section.classList.add('active');
                        found = true;
                    } else {
                        section.classList.remove('active');
                    }
                });

                if (!found) {
                    contentSections[0]?.classList.add('active');
                    targetId = contentSections[0]?.id;
                }

                sidebarLinks.forEach(link => {
                    if (link.dataset.target === targetId) {
                        link.classList.add('active');
                    } else {
                        link.classList.remove('active');
                    }
                });
            }

            sidebarNav.addEventListener('click', function(e) {
                e.preventDefault();
                const link = e.target.closest('.sidebar-link');
                if (link) {
                    const targetId = link.dataset.target;
                    showContent(targetId);
                    window.location.hash = targetId;
                }
            });

            const handleHashChange = () => {
                const targetId = window.location.hash ? window.location.hash.substring(1) : 'slide-1';
                showContent(targetId);
            };

            window.addEventListener('hashchange', handleHashChange);
            handleHashChange();
        });
    </script>
</body>
</html>
