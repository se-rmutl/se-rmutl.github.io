<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENGSE203 - แบบทดสอบสัปดาห์ที่ 7: Backend Development</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --bg-color: #f0f4f8;
            --card-bg: #ffffff;
            --text-color: #34495e;
            --success-color: #27ae60;
            --danger-color: #c0392b;
            --warning-color: #f39c12;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            --border-radius: 12px;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Sarabun', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .quiz-container {
            width: 100%;
            max-width: 800px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: height 0.4s ease-in-out;
        }

        .quiz-page {
            padding: 30px 40px;
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Welcome Page */
        #welcome-page h1 {
            color: var(--secondary-color);
            text-align: center;
            margin-bottom: 15px;
        }
        #welcome-page p {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .info-box {
            background-color: #eaf5ff;
            border-left: 5px solid var(--primary-color);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            font-size: 1em;
            font-family: 'Sarabun', sans-serif;
        }
        .start-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: 600;
            color: white;
            background-color: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .start-btn:hover {
            background-color: #2980b9;
        }

        /* Quiz Page */
        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .progress-bar-container {
            flex-grow: 1;
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin: 0 20px;
        }
        .progress-bar {
            width: 0;
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        #question-counter {
            font-weight: 600;
        }
        .question-text {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 25px;
        }
        .options-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .option {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .option:hover {
            border-color: var(--primary-color);
            background-color: #eaf5ff;
        }
        .option.selected {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        pre.code-snippet {
            background-color: #2d3142;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .quiz-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        .nav-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            background-color: var(--secondary-color);
            color: white;
            font-size: 1em;
            cursor: pointer;
        }
        .nav-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #finish-btn {
            background-color: var(--success-color);
        }

        /* Result Page */
        #result-page {
            text-align: center;
        }
        .result-summary {
            border: 1px solid #eee;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 30px;
        }
        #result-header {
            font-size: 1.8em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        .score-display {
            font-size: 2.5em;
            font-weight: 700;
            margin: 15px 0;
        }
        .score-display.pass { color: var(--success-color); }
        .score-display.fail { color: var(--danger-color); }
        
        .level-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            color: white;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .level-proficient { background-color: var(--success-color); }
        .level-competent { background-color: var(--warning-color); }
        .level-beginner { background-color: var(--danger-color); }

        .result-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        .result-actions button {
            padding: 12px 25px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            color: white;
            cursor: pointer;
        }
        #capture-btn { background-color: var(--primary-color); }
        #review-btn { background-color: var(--secondary-color); }

        /* Review Section */
        #review-section {
            display: none;
            margin-top: 30px;
            text-align: left;
        }
        .review-item {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .review-item .question-text { font-size: 1.1em; }
        .review-option {
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 8px;
            border: 1px solid #ccc;
        }
        .review-option.correct {
            background-color: #eafaf1;
            border-color: var(--success-color);
            font-weight: bold;
        }
        .review-option.incorrect {
            background-color: #fdedec;
            border-color: var(--danger-color);
            text-decoration: line-through;
        }
        .explanation {
            background-color: #fffbe6;
            border: 1px solid #f9e79f;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
        }

        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="quiz-container">
        <!-- Welcome Page -->
        <div id="welcome-page" class="quiz-page">
            <h1>แบบทดสอบสัปดาห์ที่ 7</h1>
            <p>Backend Development with Node.js</p>
            <div class="info-box">
                <p><strong>ความสำคัญของแบบทดสอบนี้:</strong> แบบทดสอบนี้ถูกออกแบบมาเพื่อทบทวนและประเมินความเข้าใจในหัวใจสำคัญของการพัฒนา Backend ซึ่งเป็นรากฐานในการสร้าง Full-Stack Application ที่สมบูรณ์ การทำความเข้าใจในเนื้อหาสัปดาห์นี้จะช่วยให้คุณสามารถเชื่อมต่อ Frontend ที่ได้เรียนไปแล้ว เข้ากับระบบจัดการข้อมูลและ Logic ที่มีประสิทธิภาพได้</p>
            </div>
            <form id="student-info-form">
                <div class="form-group">
                    <label for="fullname">ชื่อ-นามสกุล</label>
                    <input type="text" id="fullname" required>
                </div>
                <div class="form-group">
                    <label for="student-id">รหัสนักศึกษา</label>
                    <input type="text" id="student-id" required>
                </div>
                <button type="submit" class="start-btn">เริ่มทำแบบทดสอบ</button>
            </form>
        </div>

        <!-- Quiz Page -->
        <div id="quiz-page" class="quiz-page hidden">
            <div class="quiz-header">
                <h2 id="question-number"></h2>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <span id="question-counter"></span>
            </div>
            <div id="question-text" class="question-text"></div>
            <pre id="code-snippet" class="code-snippet hidden"></pre>
            <ul id="options-list" class="options-list"></ul>
            <div class="quiz-navigation">
                <button id="prev-btn" class="nav-btn">ก่อนหน้า</button>
                <button id="next-btn" class="nav-btn">ถัดไป</button>
                <button id="finish-btn" class="nav-btn hidden">ส่งคำตอบ</button>
            </div>
        </div>

        <!-- Result Page -->
        <div id="result-page" class="quiz-page hidden">
            <div class="result-summary" id="result-capture-area">
                <h1 id="result-header">ผลการทดสอบ</h1>
                <p><strong>ชื่อ:</strong> <span id="result-fullname"></span> | <strong>รหัสนักศึกษา:</strong> <span id="result-studentid"></span></p>
                <div id="score-display" class="score-display"></div>
                <div id="level-badge" class="level-badge"></div>
                <p id="level-description"></p>
                <p><strong>เกณฑ์การผ่าน:</strong> 80% ขึ้นไป</p>
            </div>
            <div class="result-actions">
                <button id="capture-btn">จับภาพผลลัพธ์</button>
                <button id="review-btn">ดูเฉลย</button>
            </div>

            <div id="review-section">
                <h2>เฉลยแบบทดสอบ</h2>
                <!-- Review items will be inserted here by JS -->
            </div>
        </div>
    </div>

    <script>
        const quizData = [
    {
        question: "ข้อใดคือเหตุผลหลักที่ทำให้ Node.js เหมาะสมกับการพัฒนา Real-time Application เช่น Agent Wallboard System?",
        options: [
            "เพราะใช้ V8 Engine ของ Google Chrome",
            "เพราะมี NPM Ecosystem ที่ใหญ่ที่สุด",
            "เพราะสถาปัตยกรรมแบบ Event-driven และ Non-blocking I/O",
            "เพราะเป็น Single-threaded"
        ],
        answer: "เพราะสถาปัตยกรรมแบบ Event-driven และ Non-blocking I/O",
        explanation: "Event-driven และ Non-blocking I/O คือหัวใจที่ทำให้ Node.js จัดการ I/O operations จำนวนมาก (เช่น WebSocket connections) ได้พร้อมกันอย่างมีประสิทธิภาพโดยไม่ต้องรอ ทำให้เหมาะกับงาน Real-time"
    },
    {
        question: "จากโค้ดต่อไปนี้ บรรทัดใดจะแสดงผลเป็นลำดับที่ 3?",
        code: `console.log('A');\nsetTimeout(() => console.log('B'), 0);\nPromise.resolve().then(() => console.log('C'));\nconsole.log('D');`,
        options: [ "A", "B", "C", "D" ],
        answer: "B",
        explanation: "ลำดับการทำงานคือ A, D (Synchronous) -> C (Microtask Queue) -> B (Macrotask/Callback Queue). ดังนั้น B จึงเป็นลำดับสุดท้ายที่แสดงผล"
    },
    {
        question: "ข้อใดคือความแตกต่างที่สำคัญที่สุดระหว่าง `dependencies` และ `devDependencies` ในไฟล์ `package.json`?",
        options: [
            "`dependencies` ใช้สำหรับตอนพัฒนาเท่านั้น `devDependencies` ใช้ตอน Production",
            "`dependencies` เป็น package ที่จำเป็นสำหรับการรันแอปพลิเคชัน ในขณะที่ `devDependencies` ใช้สำหรับเครื่องมือตอนพัฒนาเท่านั้น",
            "`dependencies` ต้องติดตั้งด้วย `npm install` ส่วน `devDependencies` ติดตั้งด้วย `npm dev-install`",
            "ไม่มีความแตกต่างที่สำคัญ สามารถใช้แทนกันได้"
        ],
        answer: "`dependencies` เป็น package ที่จำเป็นสำหรับการรันแอปพลิเคชัน ในขณะที่ `devDependencies` ใช้สำหรับเครื่องมือตอนพัฒนาเท่านั้น",
        explanation: "`dependencies` (เช่น express, cors) จะถูกติดตั้งไปด้วยเมื่อ Deploy ขึ้น Production แต่ `devDependencies` (เช่น nodemon, jest) จะถูกข้ามไปเพื่อลดขนาดของแอปพลิเคชัน"
    },
    {
        question: "Endpoint ใดที่ออกแบบตามหลัก RESTful Design ได้ดีที่สุด สำหรับการอัปเดตสถานะของ Agent ที่มี ID 'A007'?",
        options: [
            "/api/updateAgentStatus/A007",
            "/api/agents/status",
            "PATCH /api/agents/A007/status",
            "POST /api/agents/A007"
        ],
        answer: "PATCH /api/agents/A007/status",
        explanation: "RESTful design ที่ดีจะใช้ HTTP Method (PATCH) เพื่อสื่อถึงการอัปเดตบางส่วน และใช้ URL (`/api/agents/A007/status`) เพื่อระบุถึง Resource ที่ต้องการแก้ไข"
    },
    {
        question: "HTTP Status Code ใดที่เหมาะสมที่สุดที่จะส่งกลับไปเมื่อ client สร้างข้อมูลใหม่สำเร็จ?",
        options: ["200 OK", "201 Created", "204 No Content", "400 Bad Request"],
        answer: "201 Created",
        explanation: "Status code `201 Created` ถูกออกแบบมาโดยเฉพาะเพื่อบ่งบอกว่า Resource ใหม่ได้ถูกสร้างขึ้นบน Server เป็นผลสำเร็จจาก Request นั้นๆ"
    },
    {
        question: "Middleware ใน Express.js คืออะไร?",
        options: [
            "ฟังก์ชันที่ทำงานหลังสุดหลังจาก Response ถูกส่งไปแล้ว",
            "Library สำหรับจัดการ Database เท่านั้น",
            "ฟังก์ชันที่ทำงานอยู่ระหว่าง Request และ Response เพื่อจัดการงานต่างๆ",
            "ชื่อเรียกอีกอย่างของ Route handler"
        ],
        answer: "ฟังก์ชันที่ทำงานอยู่ระหว่าง Request และ Response เพื่อจัดการงานต่างๆ",
        explanation: "Middleware สามารถเข้าถึง request, response และฟังก์ชัน next() เพื่อทำงานต่างๆ เช่น logging, authentication, หรือ validation ก่อนที่ request จะไปถึง route handler"
    },
    {
        question: "ทำไมแอปพลิเคชัน Backend จึงต้องตั้งค่า CORS?",
        options: [
            "เพื่อเพิ่มความเร็วในการตอบสนองของ API",
            "เพื่อป้องกันการโจมตีแบบ SQL Injection",
            "เพื่ออนุญาตให้ Web Browser จาก Origin อื่น (เช่น React App) สามารถเรียกใช้ API ได้",
            "เพื่อเข้ารหัสข้อมูลที่ส่งระหว่าง Client และ Server"
        ],
        answer: "เพื่ออนุญาตให้ Web Browser จาก Origin อื่น (เช่น React App) สามารถเรียกใช้ API ได้",
        explanation: "เบราว์เซอร์มีนโยบายความปลอดภัย Same-Origin Policy ที่จะบล็อก request ข้าม Origin การตั้งค่า CORS ที่ฝั่ง Server เป็นการบอกเบราว์เซอร์ว่า 'ฉันอนุญาตให้เว็บจาก Origin นี้เรียกใช้ฉันได้'"
    },
    {
        question: "อะไรคือข้อเสียหลักของวิธี HTTP Polling เมื่อเทียบกับ WebSocket สำหรับ Real-time application?",
        options: [
            "ติดตั้งยากกว่า WebSocket",
            "ใช้ Bandwidth สิ้นเปลืองและไม่ Real-time จริง",
            "ไม่รองรับการส่งข้อมูลแบบ JSON",
            "มีความปลอดภัยน้อยกว่า"
        ],
        answer: "ใช้ Bandwidth สิ้นเปลืองและไม่ Real-time จริง",
        explanation: "Polling ทำให้ client ต้องส่ง request ไปถาม server ซ้ำๆ ทำให้เกิด traffic ที่ไม่จำเป็นและมีการดีเลย์เสมอ, ในขณะที่ WebSocket เป็นการเชื่อมต่อค้างไว้และ server สามารถ push ข้อมูลได้ทันที"
    },
    {
        question: "Global Error Handler ใน Express.js ควรวางไว้ที่ใดในโค้ด?",
        options: [
            "บรรทัดแรกสุดของไฟล์ server.js",
            "ก่อนการประกาศ Routes ทั้งหมด",
            "หลังจาก Middleware ที่จำเป็นทั้งหมด แต่ก่อน Routes",
            "ท้ายสุด หลังจากประกาศ Routes และ Middleware อื่นๆ ทั้งหมด"
        ],
        answer: "ท้ายสุด หลังจากประกาศ Routes และ Middleware อื่นๆ ทั้งหมด",
        explanation: "Express ประมวลผล middleware ตามลำดับ Error Handler จะทำงานเมื่อมี error เกิดขึ้นใน middleware หรือ route ก่อนหน้า ดังนั้นจึงต้องวางไว้ท้ายสุดเพื่อดักจับ error ทั้งหมดใน application"
    },
    {
        question: "จากโค้ดต่อไปนี้ หาก client ส่ง request ที่ไม่มี `title` ใน body จะเกิดอะไรขึ้น?",
        code: `app.post('/api/tasks', (req, res) => {\n  const { title } = req.body;\n  if (!title) {\n    return res.status(400).json({ error: 'Title is required' });\n  }\n  // ... create task ...\n});`,
        options: [
            "Server จะ crash",
            "จะเกิด 500 Internal Server Error",
            "Client จะได้รับ 400 Bad Request พร้อมข้อความ error",
            "Task จะถูกสร้างโดยมี title เป็นค่าว่าง"
        ],
        answer: "Client จะได้รับ 400 Bad Request พร้อมข้อความ error",
        explanation: "โค้ดมีการทำ Input Validation เพื่อตรวจสอบว่ามี `title` หรือไม่ ถ้าไม่มี จะ return response ด้วย status 400 และข้อความ error ทันที"
    },
    {
        question: "ข้อใดคือประโยชน์หลักของการใช้ Environment Variables (.env) ในการพัฒนา Backend?",
        options: [
            "ทำให้โค้ดทำงานเร็วขึ้น",
            "ช่วยแยกข้อมูลสำคัญ (เช่น รหัสผ่าน) ออกจาก Source Code เพื่อความปลอดภัย",
            "ช่วยลดจำนวนบรรทัดของโค้ด",
            "เป็นข้อบังคับของ Node.js"
        ],
        answer: "ช่วยแยกข้อมูลสำคัญ (เช่น รหัสผ่าน) ออกจาก Source Code เพื่อความปลอดภัย",
        explanation: "การใช้ .env file ช่วยให้เราไม่ต้อง hardcode ข้อมูลสำคัญเช่น DB connection strings หรือ API keys ลงในโค้ด ทำให้ปลอดภัยเมื่อแชร์โค้ด และยืดหยุ่นในการเปลี่ยนค่าตาม environment"
    },
    {
        question: "`nodemon` เป็นเครื่องมือที่มีประโยชน์อย่างไรในการพัฒนา Node.js?",
        options: [
            "ใช้สำหรับทดสอบ API performance",
            "ใช้สำหรับ Deploy แอปพลิเคชันขึ้น Production",
            "ใช้สำหรับ restart server อัตโนมัติเมื่อมีการเปลี่ยนแปลงไฟล์โค้ด",
            "ใช้สำหรับจัดการ database"
        ],
        answer: "ใช้สำหรับ restart server อัตโนมัติเมื่อมีการเปลี่ยนแปลงไฟล์โค้ด",
        explanation: "Nodemon ช่วยเพิ่มความเร็วในการพัฒนาโดยการ monitor การเปลี่ยนแปลงไฟล์ และ restart server ให้โดยอัตโนมัติ ทำให้ไม่ต้องหยุดและรัน server ใหม่ทุกครั้งที่แก้ไขโค้ด"
    },
    {
        question: "ข้อใดคือ Middleware สำเร็จรูปที่มาพร้อมกับ Express.js สำหรับแปลง request body ที่เป็น JSON?",
        options: ["express.cors()", "express.json()", "express.static()", "express.router()"],
        answer: "express.json()",
        explanation: "`express.json()` เป็น built-in middleware ที่ทำหน้าที่ parse request body ที่มี Content-Type เป็น `application/json` แล้วนำข้อมูลไปใส่ใน `req.body`"
    },
    {
        question: "เราใช้ HTTP Method ใดสำหรับดึงข้อมูล Resource ทั้งหมด (เช่น agents ทั้งหมด)?",
        options: ["GET", "POST", "PUT", "DELETE"],
        answer: "GET",
        explanation: "ตามหลัก REST, Method `GET` ถูกใช้สำหรับการร้องขอเพื่อดึงข้อมูล (Read) โดยไม่มีการเปลี่ยนแปลงข้อมูลบน Server"
    },
    {
        question: "ในสถาปัตยกรรม MVC สำหรับ API Server, 'View' คืออะไร?",
        options: [
            "ไฟล์ HTML ที่ Server ส่งกลับไป",
            "React component ที่แสดงผลข้อมูล",
            "JSON response ที่ Server ส่งกลับไปให้ client",
            "ไม่มี View Layer ใน API Server"
        ],
        answer: "JSON response ที่ Server ส่งกลับไปให้ client",
        explanation: "ในบริบทของ API, Server ไม่ได้สร้างหน้าเว็บ แต่จะส่งข้อมูลในรูปแบบที่มีโครงสร้าง (เช่น JSON) กลับไป ซึ่งทำหน้าที่เป็น 'View' หรือการแสดงผลของข้อมูลให้ client นำไปใช้ต่อ"
    },
    {
        question: "ข้อใดคือหน้าที่หลักของ `next()` function ใน Express Middleware?",
        options: [
            "จบการทำงานของ request-response cycle",
            "ส่ง response กลับไปหา client",
            "ส่งต่อการควบคุมไปยัง middleware หรือ route handler ตัวถัดไป",
            "เริ่มต้น request ใหม่"
        ],
        answer: "ส่งต่อการควบคุมไปยัง middleware หรือ route handler ตัวถัดไป",
        explanation: "การเรียก `next()` เป็นสิ่งจำเป็นเพื่อบอก Express ว่า middleware ปัจจุบันทำงานเสร็จแล้ว และให้ส่งต่อ request object ไปยังฟังก์ชันถัดไปใน chain"
    },
    {
        question: "หากต้องการป้องกันการโจมตีแบบ Brute-force login ควรใช้ Security Best Practice ใด?",
        options: [
            "Input Sanitization",
            "ใช้ Helmet",
            "Rate Limiting",
            "ใช้ .env file"
        ],
        answer: "Rate Limiting",
        explanation: "Rate Limiting (เช่นใช้ `express-rate-limit`) ช่วยจำกัดจำนวนครั้งที่ IP address หนึ่งๆ สามารถ request มายัง endpoint ที่สำคัญ (เช่น login) ได้ในหนึ่งช่วงเวลา เป็นการป้องกันการเดาสุ่มรหัสผ่าน"
    },
    {
        question: "ข้อใดคือความแตกต่างระหว่าง PUT และ PATCH?",
        options: [
            "PUT ใช้สร้าง, PATCH ใช้อัปเดต",
            "PUT ใช้อัปเดตข้อมูลทั้งหมดของ Resource, PATCH ใช้อัปเดตแค่บางส่วน",
            "PATCH ปลอดภัยกว่า PUT",
            "ไม่มีความแตกต่าง สามารถใช้แทนกันได้"
        ],
        answer: "PUT ใช้อัปเดตข้อมูลทั้งหมดของ Resource, PATCH ใช้อัปเดตแค่บางส่วน",
        explanation: "PUT เป็นการแทนที่ข้อมูลเดิมทั้งหมดด้วยข้อมูลใหม่ที่ส่งไป (ถ้า field ไหนไม่ส่งไปจะกลายเป็น null), ส่วน PATCH เป็นการอัปเดตเฉพาะ field ที่ส่งไปเท่านั้น"
    },
    {
        question: "Library ใดที่แนะนำให้ใช้สำหรับจัดการ Log อย่างมืออาชีพใน Node.js?",
        options: ["console", "logger", "Winston", "Morgan"],
        answer: "Winston",
        explanation: "Winston เป็น library สำหรับ logging ที่ได้รับความนิยมสูง มีความสามารถหลากหลาย เช่น log levels, transports (เก็บ log ได้หลายที่ เช่น file, console), และ formatting"
    },
    {
        question: "ในสัปดาห์ถัดไป (สัปดาห์ที่ 8) เราจะเปลี่ยนจากการเก็บข้อมูลแบบ In-Memory ไปเป็นอะไร?",
        options: [
            "เก็บใน Local Storage",
            "เก็บในไฟล์ .json",
            "เชื่อมต่อกับ Database (MongoDB)",
            "ใช้ WebSocket ในการเก็บข้อมูล"
        ],
        answer: "เชื่อมต่อกับ Database (MongoDB)",
        explanation: "ขั้นตอนต่อไปในการพัฒนาคือการทำให้ข้อมูลคงอยู่ถาวร (Persistent) โดยการเชื่อมต่อ Backend เข้ากับ Database ซึ่งในคอร์สนี้เราจะใช้ MongoDB"
    },
    {
        question: "หาก API endpoint หนึ่งทำงานช้า ควรใช้กลยุทธ์ใดเพื่อเพิ่มประสิทธิภาพในการตอบสนองสำหรับ request ที่ซ้ำๆ กัน?",
        options: ["Logging", "Validation", "Caching", "Rate Limiting"],
        answer: "Caching",
        explanation: "Caching คือการเก็บผลลัพธ์ของ request ที่ใช้เวลาประมวลผลนานไว้ใน memory ชั่วคราว เมื่อมี request เดิมเข้ามาอีก ก็สามารถตอบกลับด้วยข้อมูลที่ cache ไว้ได้ทันทีโดยไม่ต้องประมวลผลใหม่"
    },
    {
        question: "เครื่องมือใดที่ใช้สำหรับทดสอบ API Endpoint และสามารถสร้าง Documentation ได้ด้วย?",
        options: ["VS Code", "Node.js", "NPM", "Postman"],
        answer: "Postman",
        explanation: "Postman เป็นเครื่องมือที่ออกแบบมาเพื่อการทดสอบ API โดยเฉพาะ และมีฟีเจอร์ในการสร้างและเผยแพร่ API documentation จาก collection ที่เราสร้างไว้ได้"
    },
    {
        question: "จากโค้ดต่อไปนี้ `app.use('/api', agentRoutes);` หมายความว่าอย่างไร?",
        code: `const agentRoutes = require('./routes/agents');\napp.use('/api', agentRoutes);`,
        options: [
            "ทุก route ที่อยู่ใน `agentRoutes` จะมี prefix เป็น `/api`",
            "Middleware นี้จะทำงานกับทุก request ที่เข้ามาใน server",
            "เป็นการนำเข้า agentRoutes มาใช้งาน แต่ยังไม่ได้กำหนด path",
            "เป็นการสร้าง API endpoint ชื่อ `/api`"
        ],
        answer: "ทุก route ที่อยู่ใน `agentRoutes` จะมี prefix เป็น `/api`",
        explanation: "การใช้ `app.use` กับ path และ router เป็นการบอกว่า ทุกๆ endpoint ที่นิยามไว้ใน `agentRoutes` จะต้องมี `/api` นำหน้า เช่นถ้าใน `agentRoutes` มี `router.get('/')` path จริงจะเป็น `GET /api/`"
    },
    {
        question: "ข้อใด ไม่ใช่ คุณสมบัติหลักของ JSON?",
        options: [
            "มนุษย์อ่านเข้าใจง่าย",
            "มีน้ำหนักเบา",
            "รองรับการเขียน comment ในตัว",
            "ง่ายต่อการ parse ใน JavaScript"
        ],
        answer: "รองรับการเขียน comment ในตัว",
        explanation: "JSON format มาตรฐานไม่รองรับการเขียน comment ซึ่งเป็นหนึ่งในข้อแตกต่างจาก JavaScript Object แท้ๆ"
    },
    {
        question: "`package-lock.json` มีหน้าที่สำคัญอย่างไร?",
        options: [
            "เป็นไฟล์สำรองของ `package.json`",
            "ใช้สำหรับเก็บ devDependencies เท่านั้น",
            "ใช้สำหรับล็อกเวอร์ชันของทุก package ที่ติดตั้ง เพื่อให้ทุกคนในทีมใช้เวอร์ชันเดียวกัน",
            "ใช้สำหรับเก็บ security token ของ NPM"
        ],
        answer: "ใช้สำหรับล็อกเวอร์ชันของทุก package ที่ติดตั้ง เพื่อให้ทุกคนในทีมใช้เวอร์ชันเดียวกัน",
        explanation: "ไฟล์นี้จะบันทึกเวอร์ชันที่แน่นอนของทุก package และ dependency ย่อยๆ ของมัน เพื่อให้แน่ใจว่าเมื่อใครก็ตามรัน `npm install` จะได้ package ชุดเดียวกันเสมอ ป้องกันปัญหา 'It works on my machine'"
    },
    {
        question: "ข้อใดคือโครงสร้างโปรเจกต์ที่เหมาะสมตามหลัก Separation of Concerns?",
        options: [
            "เขียนทุกอย่างในไฟล์ `server.js` ไฟล์เดียว",
            "แยกไฟล์ตามประเภทของข้อมูล เช่น `users.js`, `products.js`",
            "แยกไฟล์ตามหน้าที่ เช่น `controllers`, `routes`, `models`",
            "แยกไฟล์ตามวันที่สร้าง"
        ],
        answer: "แยกไฟล์ตามหน้าที่ เช่น `controllers`, `routes`, `models`",
        explanation: "การแยกไฟล์ตามหน้าที่ (MVC pattern) เป็น best practice ที่ช่วยให้โค้ดเป็นระเบียบ, ทดสอบง่าย, และบำรุงรักษาสะดวก เพราะแต่ละส่วนมีหน้าที่รับผิดชอบชัดเจน"
    },
    {
        question: "เราจะเข้าถึง URL parameter ใน Express ได้อย่างไร เช่น `:id` จาก `'/users/:id'`?",
        options: ["req.body.id", "req.query.id", "req.params.id", "req.headers.id"],
        answer: "req.params.id",
        explanation: "`req.params` เป็น object ที่เก็บ route parameters ที่ถูกจับคู่จาก URL เช่น ถ้า request มาที่ `/users/123`, `req.params.id` จะมีค่าเป็น '123'"
    },
    {
        question: "หาก API ต้องทำงานกับข้อมูลที่สัมพันธ์กันอย่างซับซ้อนและต้องการความถูกต้องของข้อมูลสูง (ACID compliance) ฐานข้อมูลประเภทใดจะเหมาะสมกว่า?",
        options: ["NoSQL (เช่น MongoDB)", "SQL (เช่น PostgreSQL)", "In-Memory (เช่น Redis)", "File System"],
        answer: "SQL (เช่น PostgreSQL)",
        explanation: "ฐานข้อมูลแบบ SQL ถูกออกแบบมาเพื่อจัดการข้อมูลที่มีความสัมพันธ์กัน (Relational) และมีคุณสมบัติ ACID (Atomicity, Consistency, Isolation, Durability) ที่รับประกันความถูกต้องของ transaction"
    },
    {
        question: "ข้อใดคือตัวอย่างของ Middleware ที่จัดการ 'Authentication'?",
        options: [
            "Middleware ที่บันทึก log การ request",
            "Middleware ที่แปลง body เป็น JSON",
            "Middleware ที่ตรวจสอบ JWT token ใน header ก่อนอนุญาตให้เข้าถึง route",
            "Middleware ที่จัดการ error"
        ],
        answer: "Middleware ที่ตรวจสอบ JWT tokenใน header ก่อนอนุญาตให้เข้าถึง route",
        explanation: "Authentication middleware มีหน้าที่ตรวจสอบและยืนยันตัวตนของผู้ใช้ เช่นการถอดรหัสและตรวจสอบความถูกต้องของ token เพื่อให้แน่ใจว่าผู้ใช้มีสิทธิ์ในการเข้าถึงข้อมูล"
    },
    {
        question: "เป้าหมายสูงสุดของการเรียนรู้ในสัปดาห์ที่ 7, 8 และหลังจากนั้นคืออะไร?",
        options: [
            "เพื่อสร้าง Frontend ที่สวยงามที่สุด",
            "เพื่อเป็นผู้เชี่ยวชาญ Node.js เพียงอย่างเดียว",
            "เพื่อสร้าง Full-Stack Application ที่สมบูรณ์ มีทั้ง Frontend, Backend, และ Database",
            "เพื่อเรียนรู้การใช้ Postman"
        ],
        answer: "เพื่อสร้าง Full-Stack Application ที่สมบูรณ์ มีทั้ง Frontend, Backend, และ Database",
        explanation: "การเรียนรู้ในแต่ละสัปดาห์เป็นส่วนประกอบสำคัญในการสร้าง Full-Stack Application โดยสัปดาห์ 5-6 คือ Frontend, สัปดาห์ 7 คือ Backend, และสัปดาห์ 8 คือ Database ซึ่งเมื่อรวมกันจะกลายเป็นแอปพลิเคชันที่ทำงานได้อย่างสมบูรณ์"
    }
];

        const welcomePage = document.getElementById('welcome-page');
        const quizPage = document.getElementById('quiz-page');
        const resultPage = document.getElementById('result-page');
        const form = document.getElementById('student-info-form');
        
        const questionNumber = document.getElementById('question-number');
        const progressBar = document.getElementById('progress-bar');
        const questionCounter = document.getElementById('question-counter');
        const questionText = document.getElementById('question-text');
        const codeSnippet = document.getElementById('code-snippet');
        const optionsList = document.getElementById('options-list');
        
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const finishBtn = document.getElementById('finish-btn');
        
        let currentQuestionIndex = 0;
        let userAnswers = new Array(quizData.length).fill(null);
        let studentInfo = {};

        form.addEventListener('submit', (e) => {
            e.preventDefault();
            studentInfo.fullname = document.getElementById('fullname').value;
            studentInfo.studentId = document.getElementById('student-id').value;
            welcomePage.classList.add('hidden');
            quizPage.classList.remove('hidden');
            displayQuestion();
        });

        function displayQuestion() {
            const questionData = quizData[currentQuestionIndex];
            
            questionNumber.textContent = `คำถามข้อที่ ${currentQuestionIndex + 1}`;
            progressBar.style.width = `${((currentQuestionIndex + 1) / quizData.length) * 100}%`;
            questionCounter.textContent = `${currentQuestionIndex + 1} / ${quizData.length}`;
            questionText.textContent = questionData.question;
            
            if (questionData.code) {
                codeSnippet.textContent = questionData.code;
                codeSnippet.classList.remove('hidden');
            } else {
                codeSnippet.classList.add('hidden');
            }

            optionsList.innerHTML = '';
            questionData.options.forEach(option => {
                const li = document.createElement('li');
                li.className = 'option';
                li.textContent = option;
                if (userAnswers[currentQuestionIndex] === option) {
                    li.classList.add('selected');
                }
                li.addEventListener('click', () => selectOption(li, option));
                optionsList.appendChild(li);
            });

            updateNavigation();
        }

        function selectOption(liElement, option) {
            const selectedOption = optionsList.querySelector('.selected');
            if (selectedOption) {
                selectedOption.classList.remove('selected');
            }
            liElement.classList.add('selected');
            userAnswers[currentQuestionIndex] = option;
            updateNavigation();
        }

        function updateNavigation() {
            prevBtn.disabled = currentQuestionIndex === 0;
            nextBtn.disabled = userAnswers[currentQuestionIndex] === null || currentQuestionIndex === quizData.length - 1;
            
            if (currentQuestionIndex === quizData.length - 1) {
                nextBtn.classList.add('hidden');
                finishBtn.classList.remove('hidden');
                finishBtn.disabled = userAnswers[currentQuestionIndex] === null;
            } else {
                nextBtn.classList.remove('hidden');
                finishBtn.classList.add('hidden');
            }
        }

        prevBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            }
        });
        
        finishBtn.addEventListener('click', showResults);

        function showResults() {
            let score = 0;
            userAnswers.forEach((answer, index) => {
                if (answer === quizData[index].answer) {
                    score++;
                }
            });

            const percentage = Math.round((score / quizData.length) * 100);
            const passed = percentage >= 80;

            document.getElementById('result-fullname').textContent = studentInfo.fullname;
            document.getElementById('result-studentid').textContent = studentInfo.studentId;

            const scoreDisplay = document.getElementById('score-display');
            scoreDisplay.textContent = `${score} / ${quizData.length} (${percentage}%) - ${passed ? 'ผ่าน' : 'ไม่ผ่าน'}`;
            scoreDisplay.className = `score-display ${passed ? 'pass' : 'fail'}`;

            const levelBadge = document.getElementById('level-badge');
            const levelDescription = document.getElementById('level-description');

            if (percentage >= 80) {
                levelBadge.textContent = 'ระดับ: ยอดเยี่ยม (Proficient)';
                levelBadge.className = 'level-badge level-proficient';
                levelDescription.textContent = 'คุณมีความเข้าใจในเนื้อหาของสัปดาห์นี้อย่างลึกซึ้ง สามารถนำไปประยุกต์ใช้และต่อยอดได้ดีเยี่ยม';
            } else if (percentage >= 50) {
                levelBadge.textContent = 'ระดับ: มีความสามารถ (Competent)';
                levelBadge.className = 'level-badge level-competent';
                levelDescription.textContent = 'คุณมีความเข้าใจในแนวคิดหลักส่วนใหญ่ แต่ยังมีบางหัวข้อที่ควรทบทวนเพิ่มเติมเพื่อความแม่นยำ';
            } else {
                levelBadge.textContent = 'ระดับ: ควรทบทวนเพิ่มเติม (Beginner)';
                levelBadge.className = 'level-badge level-beginner';
                levelDescription.textContent = 'คุณควรกลับไปทบทวนเนื้อหาในสัปดาห์นี้อีกครั้งเพื่อสร้างความเข้าใจพื้นฐานให้แข็งแรงยิ่งขึ้น';
            }

            quizPage.classList.add('hidden');
            resultPage.classList.remove('hidden');
            
            buildReviewSection();
        }

        function buildReviewSection() {
            const reviewSection = document.getElementById('review-section');
            reviewSection.innerHTML = '<h2>เฉลยแบบทดสอบ</h2>';
            quizData.forEach((question, index) => {
                const item = document.createElement('div');
                item.className = 'review-item';
                
                let questionHtml = `<div class="question-text">${index + 1}. ${question.question}</div>`;
                if(question.code) {
                    questionHtml += `<pre class="code-snippet">${question.code}</pre>`;
                }

                let optionsHtml = '';
                question.options.forEach(option => {
                    let classNames = 'review-option';
                    if (option === question.answer) {
                        classNames += ' correct';
                    }
                    if (userAnswers[index] === option && option !== question.answer) {
                        classNames += ' incorrect';
                    }
                    optionsHtml += `<div class="${classNames}">${option}</div>`;
                });

                item.innerHTML = `
                    ${questionHtml}
                    ${optionsHtml}
                    <div class="explanation">
                        <strong>คำอธิบาย:</strong> ${question.explanation}
                    </div>
                `;
                reviewSection.appendChild(item);
            });
        }
        
        document.getElementById('review-btn').addEventListener('click', () => {
            const reviewSection = document.getElementById('review-section');
            reviewSection.style.display = reviewSection.style.display === 'block' ? 'none' : 'block';
        });

        document.getElementById('capture-btn').addEventListener('click', () => {
            const captureArea = document.getElementById('result-capture-area');
            const originalBorder = captureArea.style.border;
            captureArea.style.border = 'none'; // Temporarily remove border for cleaner capture

            html2canvas(captureArea, { scale: 2 }).then(canvas => {
                captureArea.style.border = originalBorder; // Restore border
                const link = document.createElement('a');
                link.download = `ENGSE203_W7_Result_${studentInfo.studentId}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        });

    </script>
</body>
</html>
