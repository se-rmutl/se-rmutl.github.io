<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENGSE203 - แบบทดสอบสัปดาห์ที่ 7 (ชุด B): Backend Development</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #8e44ad; /* New color scheme */
            --secondary-color: #34495e;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --text-color: #34495e;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f1c40f;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            --border-radius: 12px;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Sarabun', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .quiz-container {
            width: 100%;
            max-width: 800px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: height 0.4s ease-in-out;
        }

        .quiz-page {
            padding: 30px 40px;
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #welcome-page h1 {
            color: var(--secondary-color);
            text-align: center;
            margin-bottom: 15px;
        }
        #welcome-page p {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .info-box {
            background-color: #f5eef8;
            border-left: 5px solid var(--primary-color);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .form-group input {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid #ccc;
            font-size: 1em;
            font-family: 'Sarabun', sans-serif;
        }
        .start-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-weight: 600;
            color: white;
            background-color: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .start-btn:hover {
            background-color: #7d3c98;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .progress-bar-container {
            flex-grow: 1;
            height: 10px;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin: 0 20px;
        }
        .progress-bar {
            width: 0;
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        #question-counter {
            font-weight: 600;
        }
        .question-text {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 25px;
        }
        .options-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .option {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .option:hover {
            border-color: var(--primary-color);
            background-color: #f5eef8;
        }
        .option.selected {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        pre.code-snippet {
            background-color: #2d3142;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .quiz-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        .nav-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            background-color: var(--secondary-color);
            color: white;
            font-size: 1em;
            cursor: pointer;
        }
        .nav-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #finish-btn {
            background-color: var(--success-color);
        }

        #result-page {
            text-align: center;
        }
        .result-summary {
            border: 1px solid #eee;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 30px;
        }
        #result-header {
            font-size: 1.8em;
            font-weight: 700;
            margin-bottom: 10px;
        }
        .score-display {
            font-size: 2.5em;
            font-weight: 700;
            margin: 15px 0;
        }
        .score-display.pass { color: var(--success-color); }
        .score-display.fail { color: var(--danger-color); }
        
        .level-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            color: white;
            font-weight: 600;
            margin-bottom: 15px;
        }
        .level-proficient { background-color: var(--success-color); }
        .level-competent { background-color: var(--warning-color); }
        .level-beginner { background-color: var(--danger-color); }

        .result-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        .result-actions button {
            padding: 12px 25px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            color: white;
            cursor: pointer;
        }
        #capture-btn { background-color: var(--primary-color); }
        #review-btn { background-color: var(--secondary-color); }

        #review-section {
            display: none;
            margin-top: 30px;
            text-align: left;
        }
        .review-item {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .review-item .question-text { font-size: 1.1em; }
        .review-option {
            padding: 10px 15px;
            margin: 5px 0;
            border-radius: 8px;
            border: 1px solid #ccc;
        }
        .review-option.correct {
            background-color: #eafaf1;
            border-color: var(--success-color);
            font-weight: bold;
        }
        .review-option.incorrect {
            background-color: #fdedec;
            border-color: var(--danger-color);
            text-decoration: line-through;
        }
        .explanation {
            background-color: #fef9e7;
            border: 1px solid #f9e79f;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
        }

        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="quiz-container">
        <!-- Welcome Page -->
        <div id="welcome-page" class="quiz-page">
            <h1>แบบทดสอบสัปดาห์ที่ 7 (ชุด B)</h1>
            <p>Backend Development with Node.js</p>
            <div class="info-box">
                <p><strong>คำชี้แจง:</strong> แบบทดสอบนี้เป็นชุด B สำหรับประเมินความเข้าใจในหัวข้อการพัฒนา Backend ด้วย Node.js และ Express.js ขอให้นักศึกษาตั้งใจทำแบบทดสอบเพื่อวัดความรู้ความสามารถของตนเองอย่างเต็มที่</p>
            </div>
            <form id="student-info-form">
                <div class="form-group">
                    <label for="fullname">ชื่อ-นามสกุล</label>
                    <input type="text" id="fullname" required>
                </div>
                <div class="form-group">
                    <label for="student-id">รหัสนักศึกษา</label>
                    <input type="text" id="student-id" required>
                </div>
                <button type="submit" class="start-btn">เริ่มทำแบบทดสอบ</button>
            </form>
        </div>

        <!-- Quiz Page -->
        <div id="quiz-page" class="quiz-page hidden">
            <div class="quiz-header">
                <h2 id="question-number"></h2>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <span id="question-counter"></span>
            </div>
            <div id="question-text" class="question-text"></div>
            <pre id="code-snippet" class="code-snippet hidden"></pre>
            <ul id="options-list" class="options-list"></ul>
            <div class="quiz-navigation">
                <button id="prev-btn" class="nav-btn">ก่อนหน้า</button>
                <button id="next-btn" class="nav-btn">ถัดไป</button>
                <button id="finish-btn" class="nav-btn hidden">ส่งคำตอบ</button>
            </div>
        </div>

        <!-- Result Page -->
        <div id="result-page" class="quiz-page hidden">
            <div class="result-summary" id="result-capture-area">
                <h1 id="result-header">ผลการทดสอบ (ชุด B)</h1>
                <p><strong>ชื่อ:</strong> <span id="result-fullname"></span> | <strong>รหัสนักศึกษา:</strong> <span id="result-studentid"></span></p>
                <div id="score-display" class="score-display"></div>
                <div id="level-badge" class="level-badge"></div>
                <p id="level-description"></p>
                <p><strong>เกณฑ์การผ่าน:</strong> 80% ขึ้นไป</p>
            </div>
            <div class="result-actions">
                <button id="capture-btn">จับภาพผลลัพธ์</button>
                <button id="review-btn">ดูเฉลย</button>
            </div>

            <div id="review-section">
                <h2>เฉลยแบบทดสอบ (ชุด B)</h2>
                <!-- Review items will be inserted here by JS -->
            </div>
        </div>
    </div>

    <script>
        const quizData = [
    {
        question: "อะไรคือคุณสมบัติหลักของ Node.js ที่ทำให้สามารถจัดการหลาย request พร้อมกันได้อย่างมีประสิทธิภาพ แม้จะเป็น Single-threaded?",
        options: [
            "การใช้ V8 Engine",
            "Non-blocking I/O และ Event Loop",
            "การมี NPM package จำนวนมาก",
            "การเขียนโค้ดด้วย JavaScript"
        ],
        answer: "Non-blocking I/O และ Event Loop",
        explanation: "หัวใจของ Node.js คือ Event Loop ที่ทำงานร่วมกับ Non-blocking I/O ทำให้สามารถรับ request ใหม่ๆ เข้ามาได้เรื่อยๆ โดยไม่ต้องรอให้ I/O operation (เช่น การอ่านไฟล์, query database) ของ request ก่อนหน้าเสร็จสิ้น"
    },
    {
        question: "หากต้องการติดตั้ง `jest` สำหรับการทดสอบเท่านั้น ควรใช้คำสั่ง npm ใด?",
        options: [
            "npm install jest",
            "npm install --global jest",
            "npm install --save-dev jest",
            "npm install --production jest"
        ],
        answer: "npm install --save-dev jest",
        explanation: "การใช้ flag `--save-dev` หรือ `-D` จะเป็นการบันทึก package ไว้ใน `devDependencies` ซึ่งหมายความว่าเป็น package ที่จำเป็นสำหรับขั้นตอนการพัฒนา (เช่น การทดสอบ) เท่านั้น และจะไม่ถูกติดตั้งเมื่อ deploy ขึ้น production"
    },
    {
        question: "ข้อใดคือวัตถุประสงค์หลักของ `Express.js`?",
        options: [
            "เป็น JavaScript runtime environment",
            "เป็น Web framework ที่ช่วยให้การสร้าง API และ Web server ใน Node.js ง่ายขึ้น",
            "เป็นเครื่องมือสำหรับจัดการ Database โดยเฉพาะ",
            "เป็น library สำหรับการทำ Real-time communication"
        ],
        answer: "เป็น Web framework ที่ช่วยให้การสร้าง API และ Web server ใน Node.js ง่ายขึ้น",
        explanation: "Express.js เป็น framework ที่สร้างขึ้นบน Node.js เพื่อลดความซับซ้อนในการจัดการ HTTP requests, routing, และ middleware ทำให้การพัฒนา web application และ API สะดวกและรวดเร็วยิ่งขึ้น"
    },
    {
        question: "URL endpoint ใดที่ถือว่าออกแบบได้ดีตามหลัก RESTful สำหรับการดึงข้อมูล comments ทั้งหมดของ post ที่มี ID เป็น 'p123'?",
        options: [
            "GET /getCommentsForPost123",
            "POST /api/comments",
            "GET /api/posts/p123/comments",
            "GET /api/comments?postId=p123"
        ],
        answer: "GET /api/posts/p123/comments",
        explanation: "ตามหลัก RESTful, comments ถือเป็น sub-resource ของ posts ดังนั้นการเข้าถึงควรทำผ่าน resource หลัก (posts) แล้วตามด้วย ID และ sub-resource (comments) ซึ่งทำให้ URL สื่อความหมายและมีโครงสร้างชัดเจน"
    },
    {
        question: "เมื่อ client ส่งข้อมูลที่ไม่ถูกต้องตามที่ API กำหนด (เช่น ขาด field ที่จำเป็น) Server ควรตอบกลับด้วย HTTP Status Code ใด?",
        options: ["200 OK", "400 Bad Request", "404 Not Found", "500 Internal Server Error"],
        answer: "400 Bad Request",
        explanation: "`400 Bad Request` เป็น status code ที่ใช้เพื่อบ่งบอกว่า request ที่ส่งมาจาก client มีข้อผิดพลาด (เช่น syntax ไม่ถูกต้อง, ข้อมูลไม่ครบ) ทำให้ server ไม่สามารถประมวลผลต่อได้"
    },
    {
        question: "จากโค้ด `app.use(express.json());` Middleware นี้ทำหน้าที่อะไร?",
        options: [
            "อนุญาตให้ทุก request เข้ามาได้",
            "แปลง response ที่ส่งกลับไปให้เป็น JSON",
            "ทำหน้าที่เป็น logger สำหรับ request ที่เป็น JSON",
            "Parse request body ที่มี Content-Type เป็น 'application/json' ให้อยู่ใน `req.body`"
        ],
        answer: "Parse request body ที่มี Content-Type เป็น 'application/json' ให้อยู่ใน `req.body`",
        explanation: "`express.json()` เป็น built-in middleware ที่จำเป็นสำหรับการรับข้อมูล JSON จาก client ใน request body (เช่น จาก POST หรือ PATCH request) และแปลงให้อยู่ในรูปแบบ object ที่เข้าถึงได้ผ่าน `req.body`"
    },
    {
        question: "ถ้า Frontend ที่รันบน `https://app.example.com` ไม่สามารถเรียก API ที่อยู่บน `https://api.example.com` ได้ ปัญหาน่าจะเกิดจากอะไร?",
        options: [
            "Server down",
            "ไม่ได้ติดตั้ง `nodemon`",
            "ปัญหา CORS (Cross-Origin Resource Sharing)",
            "ใช้ HTTP Method ผิด"
        ],
        answer: "ปัญหา CORS (Cross-Origin Resource Sharing)",
        explanation: "เบราว์เซอร์มีนโยบายความปลอดภัยที่เรียกว่า Same-Origin Policy ซึ่งจะบล็อกการเรียก API ข้ามโดเมน (Origin) เว้นแต่ว่า Server ปลายทาง (api.example.com) จะมีการตั้งค่า Header เพื่ออนุญาต Origin ของ Frontend (app.example.com) ผ่านกลไก CORS"
    },
    {
        question: "เทคโนโลยีใดเหมาะสมที่สุดสำหรับการส่งอัปเดตสถานะ Agent แบบทันทีจาก Server ไปยัง Clients ทุกตัวที่เชื่อมต่ออยู่?",
        options: ["HTTP Polling", "Server-Sent Events (SSE)", "WebSocket", "REST API"],
        answer: "WebSocket",
        explanation: "WebSocket เป็นเทคโนโลยีที่สร้างการเชื่อมต่อแบบสองทิศทาง (bidirectional) ค้างไว้ระหว่าง client และ server ทำให้ server สามารถ 'push' ข้อมูลไปหา client ได้ทันทีที่ต้องการ ซึ่งเหมาะที่สุดสำหรับ real-time application"
    },
    {
        question: "เราจะดักจับ error ที่เกิดขึ้นใน asynchronous function ที่ใช้ `async/await` ใน Express route handler ได้อย่างไร?",
        code: `router.get('/', async (req, res, next) => {\n  // ... code that might throw error ...\n});`,
        options: [
            "ใช้ `try...catch` block แล้วเรียก `next(error)` ใน catch block",
            "Express จะจัดการให้โดยอัตโนมัติ ไม่ต้องทำอะไร",
            "ใช้ `app.on('error', ...)`",
            "ใช้ `.catch(next)` ต่อท้าย route handler"
        ],
        answer: "ใช้ `try...catch` block แล้วเรียก `next(error)` ใน catch block",
        explanation: "สำหรับ `async/await`, วิธีมาตรฐานในการดักจับ error คือการใช้ `try...catch` และเมื่อเกิด error ขึ้นใน catch block เราจะต้องส่ง error นั้นต่อไปให้ global error handler ของ Express ด้วยการเรียก `next(error)`"
    },
    {
        question: "ข้อใดคือการใช้งาน `nodemon` ที่ถูกต้อง?",
        options: [
            "ใช้ใน Production เพื่อให้ server restart อัตโนมัติเมื่อเกิดปัญหา",
            "ใช้ใน Development เพื่อ restart server อัตโนมัติเมื่อมีการแก้ไขโค้ด",
            "เป็นเครื่องมือสำหรับทดสอบ API",
            "เป็น library สำหรับจัดการ WebSocket"
        ],
        answer: "ใช้ใน Development เพื่อ restart server อัตโนมัติเมื่อมีการแก้ไขโค้ด",
        explanation: "`nodemon` เป็นเครื่องมือสำหรับ development ที่ช่วยเพิ่มความสะดวกโดยการ monitor การเปลี่ยนแปลงไฟล์ และ restart server ให้โดยอัตโนมัติ ไม่ควรใช้ใน production"
    },
    {
        question: "ข้อใด ไม่ใช่ ประโยชน์ของการจัดโครงสร้างโปรเจกต์แบบ MVC (Model-View-Controller)?",
        options: [
            "ช่วยให้โค้ดเป็นระเบียบและบำรุงรักษาง่าย (Maintainability)",
            "ช่วยให้แอปพลิเคชันทำงานเร็วขึ้น (Performance)",
            "ช่วยให้ทดสอบโค้ดได้ง่ายขึ้น (Testability)",
            "ช่วยให้ทีมทำงานร่วมกันได้ง่ายขึ้น (Collaboration)"
        ],
        answer: "ช่วยให้แอปพลิเคชันทำงานเร็วขึ้น (Performance)",
        explanation: "MVC เป็นรูปแบบการออกแบบที่เน้นเรื่องการจัดระเบียบโค้ด (Separation of Concerns) ซึ่งส่งผลดีต่อการบำรุงรักษา, การทดสอบ, และการทำงานร่วมกัน แต่ไม่ได้การันตีว่าจะทำให้แอปพลิเคชันทำงานเร็วขึ้นโดยตรง"
    },
    {
        question: "คำสั่ง `npm init -y` ทำหน้าที่อะไร?",
        options: [
            "ติดตั้ง Node.js และ NPM",
            "สร้างไฟล์ `package.json` ด้วยค่าเริ่มต้นโดยอัตโนมัติ",
            "ลบ `node_modules` ทั้งหมด",
            "อัปเดต package ทั้งหมด"
        ],
        answer: "สร้างไฟล์ `package.json` ด้วยค่าเริ่มต้นโดยอัตโนมัติ",
        explanation: "`npm init` ใช้สำหรับเริ่มต้นโปรเจกต์และสร้างไฟล์ `package.json`, ส่วน flag `-y` (yes) เป็นการบอกให้ใช้ค่าเริ่มต้นทั้งหมดโดยไม่ต้องถามคำถาม"
    },
    {
        question: "ใน Express.js, `req.params` และ `req.query` ต่างกันอย่างไร?",
        options: [
            "`req.params` มาจาก URL path, `req.query` มาจาก request body",
            "`req.params` มาจาก URL path (เช่น /users/:id), `req.query` มาจาก query string (เช่น ?status=active)",
            "`req.query` มาจาก URL path, `req.params` มาจาก query string",
            "ไม่มีความแตกต่าง สามารถใช้แทนกันได้"
        ],
        answer: "`req.params` มาจาก URL path (เช่น /users/:id), `req.query` มาจาก query string (เช่น ?status=active)",
        explanation: "`req.params` ใช้สำหรับดึงค่า parameter ที่เป็นส่วนหนึ่งของ URL path (เช่น ID), ส่วน `req.query` ใช้สำหรับดึงค่าจาก query string ที่อยู่หลัง `?` ซึ่งมักใช้สำหรับการกรอง, จัดเรียง, หรือ pagination"
    },
    {
        question: "ถ้าต้องการส่งข้อมูลกลับไปหา client พร้อมกับตั้งค่า HTTP Status Code, ควรใช้ method ใดของ `res` object?",
        options: [
            "res.send({ status: 200, data: ... })",
            "res.status(200).send({ data: ... })",
            "res.json({ data: ... }).status(200)",
            "res.write(200, { data: ... })"
        ],
        answer: "res.status(200).send({ data: ... })",
        explanation: "Method `res.status()` ใช้สำหรับตั้งค่า HTTP status code และมันจะ return `res` object กลับมา ทำให้เราสามารถ chain method อื่นๆ เช่น `send()` หรือ `json()` ต่อได้"
    },
    {
        question: "ข้อใดคือเหตุผลหลักที่ควรใช้ `process.env` เพื่อเข้าถึงค่า Configuration?",
        options: [
            "เป็นวิธีที่เร็วที่สุดในการเข้าถึงข้อมูล",
            "เพื่อแยกค่า Config ที่อาจเปลี่ยนแปลงหรือเป็นความลับออกจาก Source Code",
            "เพื่อทำให้โค้ดอ่านง่ายขึ้น",
            "เป็นวิธีเดียวที่ Node.js รองรับ"
        ],
        answer: "เพื่อแยกค่า Config ที่อาจเปลี่ยนแปลงหรือเป็นความลับออกจาก Source Code",
        explanation: "การใช้ Environment Variables ช่วยให้เราสามารถเปลี่ยนค่า Config (เช่น Database URL, API Keys) ได้โดยไม่ต้องแก้ไขโค้ด และป้องกันข้อมูลสำคัญหลุดขึ้นไปบน Git Repository"
    },
    {
        question: "หน้าที่ของไฟล์ `package-lock.json` คืออะไร?",
        options: [
            "เป็นไฟล์สำรองของ `package.json`",
            "ล็อกเวอร์ชันที่แน่นอนของทุก package เพื่อให้การติดตั้งซ้ำได้ผลลัพธ์เหมือนเดิม",
            "ใช้สำหรับเขียน test script",
            "ใช้สำหรับเก็บ Log การติดตั้ง package"
        ],
        answer: "ล็อกเวอร์ชันที่แน่นอนของทุก package เพื่อให้การติดตั้งซ้ำได้ผลลัพธ์เหมือนเดิม",
        explanation: "ไฟล์นี้จะบันทึกโครงสร้าง dependency tree ทั้งหมดพร้อมเวอร์ชันที่แน่นอน เพื่อให้แน่ใจว่าทุกคนในทีม (หรือระบบ CI/CD) เมื่อรัน `npm install` จะได้ package ชุดเดียวกันเสมอ ป้องกันปัญหา 'It works on my machine'"
    },
    {
        question: "Middleware `helmet` มีประโยชน์อย่างไร?",
        options: [
            "ช่วยจัดการ WebSocket connection",
            "ช่วยบีบอัด response body",
            "ช่วยตั้งค่า HTTP headers ต่างๆ เพื่อเพิ่มความปลอดภัยให้กับแอปพลิเคชัน",
            "ช่วยจัดการ Error handling"
        ],
        answer: "ช่วยตั้งค่า HTTP headers ต่างๆ เพื่อเพิ่มความปลอดภัยให้กับแอปพลิเคชัน",
        explanation: "`helmet` เป็น middleware ที่ช่วยป้องกันช่องโหว่ความปลอดภัยที่รู้จักกันดีโดยการตั้งค่า HTTP response headers ที่เหมาะสม เช่น X-Content-Type-Options, Strict-Transport-Security, X-Frame-Options เป็นต้น"
    },
    {
        question: "ถ้า API ของเราต้องจัดการกับข้อมูลทางการเงินที่ต้องการความถูกต้องสูงสุด ควรเลือกใช้ฐานข้อมูลประเภทใดในสัปดาห์หน้า?",
        options: [
            "NoSQL (เช่น MongoDB) เพราะยืดหยุ่น",
            "SQL (เช่น PostgreSQL) เพราะมี ACID compliance",
            "In-Memory (เช่น Redis) เพราะเร็ว",
            "File-based (เช่น JSON file) เพราะง่าย"
        ],
        answer: "SQL (เช่น PostgreSQL) เพราะมี ACID compliance",
        explanation: "ฐานข้อมูลแบบ SQL มีคุณสมบัติ ACID (Atomicity, Consistency, Isolation, Durability) ที่รับประกันความถูกต้องของการทำธุรกรรม (Transaction) ซึ่งสำคัญอย่างยิ่งสำหรับข้อมูลทางการเงิน"
    },
    {
        question: "ข้อใดคือตัวอย่างของ Unit Test สำหรับ Backend?",
        options: [
            "การทดสอบว่าเมื่อคลิกปุ่มบนหน้าเว็บแล้วข้อมูลถูกบันทึกถูกต้องหรือไม่",
            "การทดสอบ API endpoint `POST /users` ด้วย Postman",
            "การทดสอบฟังก์ชัน `calculateTotalPrice(items)` ว่าคำนวณราคาได้ถูกต้องหรือไม่",
            "การทดสอบว่าระบบสามารถรองรับผู้ใช้ 100 คนพร้อมกันได้หรือไม่"
        ],
        answer: "การทดสอบฟังก์ชัน `calculateTotalPrice(items)` ว่าคำนวณราคาได้ถูกต้องหรือไม่",
        explanation: "Unit Test คือการทดสอบหน่วยย่อยที่สุดของโค้ด (เช่น ฟังก์ชันเดียว) โดยแยกออกจากส่วนอื่นๆ เพื่อให้แน่ใจว่าฟังก์ชันนั้นทำงานได้ถูกต้องตามที่คาดหวัง"
    },
    {
        question: "ถ้าเรามี Route handler ดังนี้ `router.get('/search', ...)` และผู้ใช้เรียก URL `.../search?q=nodejs&page=1` เราจะเข้าถึงค่า 'nodejs' ได้อย่างไร?",
        code: `router.get('/search', (req, res) => {\n  // your code here\n});`,
        options: [
            "`req.params.q`",
            "`req.body.q`",
            "`req.query.q`",
            "`req.headers.q`"
        ],
        answer: "`req.query.q`",
        explanation: "ข้อมูลที่อยู่หลังเครื่องหมาย `?` ใน URL เรียกว่า Query String และ Express จะ parse ข้อมูลส่วนนี้มาเก็บไว้ใน object `req.query`"
    },
    {
        question: "ข้อใด ไม่ใช่ หน้าที่หลักของ API Server?",
        options: [
            "รับ request จาก client",
            "ประมวลผล Business Logic",
            "ติดต่อกับ Database",
            "Render HTML เพื่อแสดงผลบนเบราว์เซอร์"
        ],
        answer: "Render HTML เพื่อแสดงผลบนเบราว์เซอร์",
        explanation: "ในสถาปัตยกรรมสมัยใหม่ API Server ส่วนใหญ่จะทำหน้าที่จัดการข้อมูลและ Logic แล้วส่งข้อมูลกลับไปในรูปแบบ JSON ส่วนการ Render หน้าเว็บ (HTML) จะเป็นหน้าที่ของ Frontend framework (เช่น React)"
    },
    {
        question: "ข้อใดคือความเสี่ยงของการเขียนโค้ดแบบ 'Callback Hell'?",
        options: [
            "ทำให้โค้ดทำงานช้าลง",
            "ทำให้โค้ดอ่านยาก, บำรุงรักษายาก, และจัดการ error ได้ลำบาก",
            "ใช้หน่วยความจำมากกว่าปกติ",
            "ไม่สามารถทำงานแบบ asynchronous ได้"
        ],
        answer: "ทำให้โค้ดอ่านยาก, บำรุงรักษายาก, และจัดการ error ได้ลำบาก",
        explanation: "Callback Hell หรือ Pyramid of Doom คือการที่ callback function ซ้อนกันลึกเกินไป ทำให้โครงสร้างโค้ดอ่านและทำความเข้าใจได้ยาก ซึ่ง `async/await` ถูกสร้างขึ้นมาเพื่อแก้ปัญหานี้"
    },
    {
        question: "`app.use(express.static('public'))` ทำหน้าที่อะไร?",
        options: [
            "ทำให้ทุกไฟล์ในโปรเจกต์เป็น static",
            "Serve ไฟล์ที่อยู่ในโฟลเดอร์ `public` ให้เข้าถึงได้โดยตรงผ่าน URL",
            "สร้างโฟลเดอร์ชื่อ `public`",
            "เป็น Middleware สำหรับความปลอดภัย"
        ],
        answer: "Serve ไฟล์ที่อยู่ในโฟลเดอร์ `public` ให้เข้าถึงได้โดยตรงผ่าน URL",
        explanation: "Middleware นี้ใช้สำหรับ serve static assets เช่น รูปภาพ, CSS, หรือไฟล์ JavaScript โดยถ้ามีไฟล์ชื่อ `image.jpg` ในโฟลเดอร์ `public` เราจะสามารถเข้าถึงได้ผ่าน URL `http://your-server/image.jpg`"
    },
    {
        question: "หากต้องการส่งข้อมูลที่มี sensitive data (เช่น Token) จาก client ไปยัง server ควรส่งผ่านทางใด?",
        options: [
            "URL Query String (/?token=...)",
            "URL Path (/users/token/...) ",
            "HTTP Request Header (Authorization: Bearer ...)",
            "Request Body ของ GET request"
        ],
        answer: "HTTP Request Header (Authorization: Bearer ...)",
        explanation: "การส่งข้อมูลสำคัญควรทำผ่าน HTTP Header (โดยเฉพาะ Authorization header) เพราะมีความปลอดภัยมากกว่าการส่งผ่าน URL ซึ่งอาจถูกเก็บไว้ใน log หรือ browser history"
    },
    {
        question: "Graceful Shutdown มีความสำคัญอย่างไรใน Production environment?",
        options: [
            "ทำให้ server ปิดตัวเร็วขึ้น",
            "ช่วยให้แน่ใจว่า server จัดการ request ที่ค้างอยู่ให้เสร็จและปิดการเชื่อมต่อต่างๆ (เช่น database) อย่างถูกต้องก่อนปิดตัวลง",
            "เป็นฟีเจอร์สำหรับ restart server อัตโนมัติ",
            "ช่วยลบ log file ทั้งหมดเมื่อ server ปิดตัว"
        ],
        answer: "ช่วยให้แน่ใจว่า server จัดการ request ที่ค้างอยู่ให้เสร็จและปิดการเชื่อมต่อต่างๆ (เช่น database) อย่างถูกต้องก่อนปิดตัวลง",
        explanation: "Graceful Shutdown ป้องกันข้อมูลสูญหายหรือเสียหายโดยการให้เวลา server ในการทำงานที่ค้างอยู่ให้เสร็จสิ้นก่อนที่จะปิดตัวลงอย่างสมบูรณ์ ซึ่งสำคัญมากในระบบที่ต้องมีการอัปเดตข้อมูล"
    },
    {
        question: "ข้อใดคือตัวอย่างของ Race Condition ใน Backend?",
        options: [
            "Server ตอบกลับช้าเมื่อมีผู้ใช้เยอะ",
            "ผู้ใช้ 2 คนพยายามจองที่นั่งสุดท้ายของโรงหนังในเวลาเดียวกัน และทั้งคู่จองสำเร็จ",
            "ผู้ใช้กรอกรหัสผ่านผิด",
            "Database connection หลุด"
        ],
        answer: "ผู้ใช้ 2 คนพยายามจองที่นั่งสุดท้ายของโรงหนังในเวลาเดียวกัน และทั้งคู่จองสำเร็จ",
        explanation: "Race Condition คือข้อผิดพลาดที่เกิดขึ้นเมื่อลำดับการทำงานของหลายๆ process หรือ thread ที่เข้าถึง resource เดียวกันไม่เป็นไปตามที่คาดหวัง ทำให้เกิดผลลัพธ์ที่ผิดพลาด เช่น การขายของเกินสต็อก"
    },
    {
        question: "การทำ API Documentation มีประโยชน์ต่อใครมากที่สุด?",
        options: [
            "ผู้ใช้งานทั่วไป",
            "Backend developers เพียงฝ่ายเดียว",
            "Frontend developers ที่ต้องนำ API ไปใช้งาน",
            "ผู้ดูแลระบบ Server"
        ],
        answer: "Frontend developers ที่ต้องนำ API ไปใช้งาน",
        explanation: "Documentation เปรียบเสมือน 'สัญญา' หรือคู่มือที่ทำให้ทีม Frontend ทราบว่า API มี endpoint อะไรบ้าง, ต้องส่งข้อมูลรูปแบบไหน, และจะได้รับข้อมูลอะไรกลับมา ทำให้ทั้งสองทีมทำงานร่วมกันได้อย่างราบรื่น"
    },
    {
        question: "ข้อใดคือการทำงานของ Microtask Queue ใน Event Loop?",
        options: [
            "ทำงานหลังจาก Macrotask (setTimeout, setInterval) เสมอ",
            "ทำงานก่อน Macrotask แต่หลังโค้ด Synchronous ทั้งหมด",
            "ทำงานพร้อมกับโค้ด Synchronous",
            "เป็นคิวสำหรับจัดการ I/O เท่านั้น"
        ],
        answer: "ทำงานก่อน Macrotask แต่หลังโค้ด Synchronous ทั้งหมด",
        explanation: "Event Loop จะประมวลผลงานใน Microtask Queue (เช่น Promise `.then()`) ทั้งหมดจนหมดคิวก่อน ถึงจะไปหยิบงานใน Macrotask Queue (เช่น `setTimeout`) มาทำเพียง 1 งาน แล้ววนกลับไปเช็ค Microtask อีกครั้ง"
    },
    {
        question: "การใช้ `socket.io` ใน Agent Wallboard System มีวัตถุประสงค์หลักเพื่ออะไร?",
        options: [
            "เพื่อจัดการ Database",
            "เพื่อทำ Authentication",
            "เพื่อสร้างการสื่อสารแบบ Real-time สองทิศทาง",
            "เพื่อบีบอัดขนาดไฟล์"
        ],
        answer: "เพื่อสร้างการสื่อสารแบบ Real-time สองทิศทาง",
        explanation: "`socket.io` เป็น library ที่สร้างขึ้นบน WebSocket เพื่อให้การพัฒนา real-time application ง่ายขึ้น เหมาะอย่างยิ่งสำหรับการ push การอัปเดตสถานะ Agent จาก server ไปยัง client ทุกตัวทันที"
    },
    {
        question: "หลังจากเรียนจบสัปดาห์นี้และสัปดาห์หน้าแล้ว เราจะได้ผลลัพธ์สุดท้ายเป็นอะไร?",
        options: [
            "API Server ที่ทำงานได้แต่ไม่มีข้อมูลถาวร",
            "Frontend Application ที่สวยงาม",
            "Database ที่ออกแบบมาอย่างดี",
            "Full-Stack Application ที่มีทั้ง Frontend, Backend, และ Database ที่เชื่อมต่อกัน"
        ],
        answer: "Full-Stack Application ที่มีทั้ง Frontend, Backend, และ Database ที่เชื่อมต่อกัน",
        explanation: "เป้าหมายของการเรียนรู้ในช่วงนี้คือการนำความรู้ทั้ง 3 ส่วน (Frontend, Backend, Database) มาประกอบกันเพื่อสร้างเป็น Full-Stack Application ที่ทำงานได้อย่างสมบูรณ์"
    }
];

        const welcomePage = document.getElementById('welcome-page');
        const quizPage = document.getElementById('quiz-page');
        const resultPage = document.getElementById('result-page');
        const form = document.getElementById('student-info-form');
        
        const questionNumber = document.getElementById('question-number');
        const progressBar = document.getElementById('progress-bar');
        const questionCounter = document.getElementById('question-counter');
        const questionText = document.getElementById('question-text');
        const codeSnippet = document.getElementById('code-snippet');
        const optionsList = document.getElementById('options-list');
        
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const finishBtn = document.getElementById('finish-btn');
        
        let currentQuestionIndex = 0;
        let userAnswers = new Array(quizData.length).fill(null);
        let studentInfo = {};

        form.addEventListener('submit', (e) => {
            e.preventDefault();
            studentInfo.fullname = document.getElementById('fullname').value;
            studentInfo.studentId = document.getElementById('student-id').value;
            welcomePage.classList.add('hidden');
            quizPage.classList.remove('hidden');
            displayQuestion();
        });

        function displayQuestion() {
            const questionData = quizData[currentQuestionIndex];
            
            questionNumber.textContent = `คำถามข้อที่ ${currentQuestionIndex + 1}`;
            progressBar.style.width = `${((currentQuestionIndex + 1) / quizData.length) * 100}%`;
            questionCounter.textContent = `${currentQuestionIndex + 1} / ${quizData.length}`;
            questionText.textContent = questionData.question;
            
            if (questionData.code) {
                codeSnippet.textContent = questionData.code;
                codeSnippet.classList.remove('hidden');
            } else {
                codeSnippet.classList.add('hidden');
            }

            optionsList.innerHTML = '';
            questionData.options.forEach(option => {
                const li = document.createElement('li');
                li.className = 'option';
                li.textContent = option;
                if (userAnswers[currentQuestionIndex] === option) {
                    li.classList.add('selected');
                }
                li.addEventListener('click', () => selectOption(li, option));
                optionsList.appendChild(li);
            });

            updateNavigation();
        }

        function selectOption(liElement, option) {
            const selectedOption = optionsList.querySelector('.selected');
            if (selectedOption) {
                selectedOption.classList.remove('selected');
            }
            liElement.classList.add('selected');
            userAnswers[currentQuestionIndex] = option;
            updateNavigation();
        }

        function updateNavigation() {
            prevBtn.disabled = currentQuestionIndex === 0;
            nextBtn.disabled = userAnswers[currentQuestionIndex] === null || currentQuestionIndex === quizData.length - 1;
            
            if (currentQuestionIndex === quizData.length - 1) {
                nextBtn.classList.add('hidden');
                finishBtn.classList.remove('hidden');
                finishBtn.disabled = userAnswers[currentQuestionIndex] === null;
            } else {
                nextBtn.classList.remove('hidden');
                finishBtn.classList.add('hidden');
            }
        }

        prevBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            }
        });
        
        finishBtn.addEventListener('click', showResults);

        function showResults() {
            let score = 0;
            userAnswers.forEach((answer, index) => {
                if (answer === quizData[index].answer) {
                    score++;
                }
            });

            const percentage = Math.round((score / quizData.length) * 100);
            const passed = percentage >= 80;

            document.getElementById('result-fullname').textContent = studentInfo.fullname;
            document.getElementById('result-studentid').textContent = studentInfo.studentId;

            const scoreDisplay = document.getElementById('score-display');
            scoreDisplay.textContent = `${score} / ${quizData.length} (${percentage}%) - ${passed ? 'ผ่าน' : 'ไม่ผ่าน'}`;
            scoreDisplay.className = `score-display ${passed ? 'pass' : 'fail'}`;

            const levelBadge = document.getElementById('level-badge');
            const levelDescription = document.getElementById('level-description');

            if (percentage >= 80) {
                levelBadge.textContent = 'ระดับ: ยอดเยี่ยม (Proficient)';
                levelBadge.className = 'level-badge level-proficient';
                levelDescription.textContent = 'คุณมีความเข้าใจในเนื้อหาของสัปดาห์นี้อย่างลึกซึ้ง สามารถนำไปประยุกต์ใช้และต่อยอดได้ดีเยี่ยม';
            } else if (percentage >= 50) {
                levelBadge.textContent = 'ระดับ: มีความสามารถ (Competent)';
                levelBadge.className = 'level-badge level-competent';
                levelDescription.textContent = 'คุณมีความเข้าใจในแนวคิดหลักส่วนใหญ่ แต่ยังมีบางหัวข้อที่ควรทบทวนเพิ่มเติมเพื่อความแม่นยำ';
            } else {
                levelBadge.textContent = 'ระดับ: ควรทบทวนเพิ่มเติม (Beginner)';
                levelBadge.className = 'level-badge level-beginner';
                levelDescription.textContent = 'คุณควรกลับไปทบทวนเนื้อหาในสัปดาห์นี้อีกครั้งเพื่อสร้างความเข้าใจพื้นฐานให้แข็งแรงยิ่งขึ้น';
            }

            quizPage.classList.add('hidden');
            resultPage.classList.remove('hidden');
            
            buildReviewSection();
        }

        function buildReviewSection() {
            const reviewSection = document.getElementById('review-section');
            reviewSection.innerHTML = '<h2>เฉลยแบบทดสอบ (ชุด B)</h2>';
            quizData.forEach((question, index) => {
                const item = document.createElement('div');
                item.className = 'review-item';
                
                let questionHtml = `<div class="question-text">${index + 1}. ${question.question}</div>`;
                if(question.code) {
                    questionHtml += `<pre class="code-snippet">${question.code}</pre>`;
                }

                let optionsHtml = '';
                question.options.forEach(option => {
                    let classNames = 'review-option';
                    if (option === question.answer) {
                        classNames += ' correct';
                    }
                    if (userAnswers[index] === option && option !== question.answer) {
                        classNames += ' incorrect';
                    }
                    optionsHtml += `<div class="${classNames}">${option}</div>`;
                });

                item.innerHTML = `
                    ${questionHtml}
                    ${optionsHtml}
                    <div class="explanation">
                        <strong>คำอธิบาย:</strong> ${question.explanation}
                    </div>
                `;
                reviewSection.appendChild(item);
            });
        }
        
        document.getElementById('review-btn').addEventListener('click', () => {
            const reviewSection = document.getElementById('review-section');
            reviewSection.style.display = reviewSection.style.display === 'block' ? 'none' : 'block';
        });

        document.getElementById('capture-btn').addEventListener('click', () => {
            const captureArea = document.getElementById('result-capture-area');
            const originalBorder = captureArea.style.border;
            captureArea.style.border = 'none'; // Temporarily remove border for cleaner capture

            html2canvas(captureArea, { scale: 2 }).then(canvas => {
                captureArea.style.border = originalBorder; // Restore border
                const link = document.createElement('a');
                link.download = `ENGSE203_W7_Result_SetB_${studentInfo.studentId}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        });

    </script>
</body>
</html>
