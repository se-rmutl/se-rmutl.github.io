<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENGSE206 - Week 6: Design Patterns (ฉบับสมบูรณ์)</title>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #0D204E;
            /* RMUTL Navy Blue */
            --secondary-color: #D4A237;
            /* RMUTL Gold */
            --accent-color: #10B981;
            /* Tech Green */
            --background-gradient: linear-gradient(135deg, #0D204E 0%, #1a3a8a 100%);
            --slide-bg: #FFFFFF;
            --text-color-dark: #333;
            --text-color-light: #FFFFFF;
            --header-color: #0D204E;
            --base-font-size: 20px;
            /* Base for dynamic font scaling */
            --border-radius: 15px;
            --code-font: 'Fira Code', 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Sarabun', sans-serif;
            background-color: var(--primary-color);
        }

        body {
            font-size: var(--base-font-size);
            line-height: 1.7;
        }

        .presentation-container {
            width: 100%;
            height: 100%;
            padding: 2vh 3vw;
        }

        .slide {
            width: 100%;
            height: 100%;
            padding: 30px 40px 80px 40px;
            border-radius: var(--border-radius);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            background: var(--slide-bg);
            color: var(--text-color-dark);
            overflow-y: auto;
            position: relative;
            display: none;
            /* Hide slides by default */
            flex-direction: column;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .slide::-webkit-scrollbar {
            display: none;
        }

        .slide.active {
            display: flex;
            /* Show only the active slide */
            animation: fadeIn 0.4s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .title-slide,
        .separator-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: var(--background-gradient);
            color: var(--text-color-light);
        }

        .title-slide h1,
        .title-slide h2,
        .title-slide h3,
        .title-slide p,
        .separator-slide h1,
        .separator-slide h2,
        .separator-slide h3 {
            color: var(--text-color-light) !important;
            border: none;
        }

        .title-slide h1 {
            font-size: 3.5em;
            font-weight: 700;
            margin: 0.2em 0;
        }

        .title-slide h2 {
            font-size: 2.2em;
            font-weight: 500;
        }

        .title-slide h3 {
            font-size: 1.8em;
            font-weight: 400;
            opacity: 0.9;
        }

        .title-slide p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .separator-slide h2 {
            color: var(--secondary-color) !important;
            font-size: 2.5em;
        }

        .separator-slide h1 {
            font-size: 4em;
        }

        .separator-slide h3 {
            font-size: 2em;
            font-weight: 400;
            opacity: 0.9;
        }

        .progress-bar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.2);
            z-index: 2000;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(120deg, var(--secondary-color) 0%, #f1c40f 100%);
            transition: width 0.3s ease-out;
        }

        .presentation-controls {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(13, 32, 78, 0.9);
            padding: 10px 15px;
            border-radius: 50px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            z-index: 1000;
        }

        .nav-btn,
        .font-btn,
        .fullscreen-btn {
            background: transparent;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 45px;
            height: 45px;
            font-size: 1.5rem;
        }

        .nav-btn:hover:not(:disabled),
        .font-btn:hover,
        .fullscreen-btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
        }

        .nav-btn:disabled {
            color: #777;
            cursor: not-allowed;
            transform: none;
            background: transparent;
        }

        #slide-counter {
            color: white;
            font-weight: 500;
            font-size: 1.1em;
            min-width: 70px;
            text-align: center;
        }

        .slide-number {
            position: absolute;
            bottom: 20px;
            right: 40px;
            background: rgba(13, 32, 78, 0.8);
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .slide h2 {
            font-size: 2.2em;
            color: var(--header-color);
            border-bottom: 3px solid var(--secondary-color);
            padding-bottom: 8px;
            margin: 1em 0;
            font-weight: 700;
        }

        .slide h3 {
            font-size: 1.6em;
            color: var(--primary-color);
            margin-top: 1.5em;
            font-weight: 700;
        }

        p,
        ul,
        ol {
            max-width: 85ch;
            font-size: 1em;
        }

        ul.checklist li::before {
            content: "✅";
            color: var(--accent-color);
        }

        ul {
            list-style: none;
            padding-left: 0;
        }

        ul li {
            position: relative;
            padding-left: 30px;
            margin-bottom: 12px;
        }

        ul li::before {
            content: "▶";
            color: var(--primary-color);
            position: absolute;
            left: 0;
            top: 0px;
            font-size: 1.1em;
        }

        .grid-2,
        .grid-3 {
            display: grid;
            gap: 25px;
            margin: 20px 0;
            align-items: stretch;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }

        .infographic-card {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-top: 5px solid var(--primary-color);
            border-radius: var(--border-radius);
            padding: 25px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        .infographic-card .icon {
            font-size: 3.5em;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .infographic-card h4 {
            font-size: 1.2em;
            color: var(--header-color);
            margin: 0 0 10px;
        }

        .infographic-card p,
        .infographic-card ul {
            font-size: 0.9em;
            color: #555;
            flex-grow: 1;
        }

        blockquote {
            border-left: 5px solid var(--secondary-color);
            margin: 1.5em 0;
            padding: 1em 1.5em;
            background-color: #fff9e6;
            font-style: italic;
        }

        .solution {
            border-left: 4px solid var(--accent-color);
            background: #e8f8f5;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 8px 8px 0;
        }

        .anti-pattern {
            border-left: 4px solid #c0392b;
            background: #fdedec;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 8px 8px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9em;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border-radius: var(--border-radius);
            overflow: hidden;
        }

        table th {
            background: var(--header-color);
            color: white;
            padding: 12px;
            text-align: left;
        }

        table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }

        table tr:nth-child(even) {
            background: #f9f9f9;
        }

        table td:first-child {
            font-weight: bold;
        }

        /* Timeline Specific CSS */
        .timeline {
            position: relative;
            max-width: 800px;
            margin: 30px auto;
        }

        .timeline::after {
            content: '';
            position: absolute;
            width: 6px;
            background-color: #e0e0e0;
            top: 0;
            bottom: 0;
            left: 50%;
            margin-left: -3px;
        }

        .timeline-container {
            padding: 10px 40px;
            position: relative;
            background-color: inherit;
            width: 50%;
        }

        .timeline-container.left {
            left: 0;
        }

        .timeline-container.right {
            left: 50%;
        }

        .timeline-container::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            right: -17px;
            background-color: white;
            border: 4px solid var(--secondary-color);
            top: 15px;
            border-radius: 50%;
            z-index: 1;
        }

        .timeline-container.right::after {
            left: -14px;
        }

        .timeline-container.current::after {
            background-color: var(--secondary-color);
            border: 4px solid var(--accent-color);
        }

        .timeline-content {
            padding: 20px;
            background-color: white;
            position: relative;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-left: 5px solid var(--secondary-color);
        }

        .timeline-container.right .timeline-content {
            border-left: none;
            border-right: 5px solid var(--secondary-color);
        }

        .timeline-container.current .timeline-content {
            border-color: var(--accent-color);
            background-color: #e8f8f5;
        }

        .timeline-content h3 {
            font-size: 1.2em;
            margin-top: 0;
        }

        .timeline-content p {
            font-size: 0.9em;
            margin-bottom: 0;
        }
    </style>
</head>

<body>

    <div class="progress-bar-container">
        <div class="progress-bar" id="progress-bar"></div>
    </div>

    <div class="presentation-container">
        <section class="slide title-slide active">
            <h2>ENGSE206: Software Requirements Specification and Design</h2>
            <h1>สัปดาห์ที่ 6: Design Patterns และ Architectural Patterns</h1>
            <h3 style="margin-top: 30px;">อ.ธนิต เกตุแก้ว</h3>
            <p>วิศวกรรมซอฟต์แวร์, มหาวิทยาลัยเทคโนโลยีราชมงคลล้านนา (ดอยสะเก็ด)</p>
            <div class="slide-number">1/28</div>
        </section>

        <section class="slide">
            <h2>🎯 วัตถุประสงค์และเป้าหมายการเรียนรู้</h2>
            <div class="grid-3">
                <div class="infographic-card">
                    <div class="icon">📚</div>
                    <h4>เข้าใจแนวคิด</h4>
                    <p>เข้าใจแนวคิด Design Patterns และประโยชน์ในการพัฒนาซอฟต์แวร์</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🎯</div>
                    <h4>เลือกใช้ Patterns</h4>
                    <p>เลือกใช้ Design Patterns และ Architectural Patterns ที่เหมาะสมกับระบบ Real-time Communication</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">📊</div>
                    <h4>ออกแบบ Component</h4>
                    <p>ออกแบบ Component Architecture ด้วย Patterns สำหรับ Agent Wallboard System</p>
                </div>
            </div>
            <h3>ผลที่คาดหวัง</h3>
            <ul class="checklist">
                <li>สามารถระบุและแก้ไขปัญหาการออกแบบด้วย Design Patterns</li>
                <li>ออกแบบระบบที่มีโครงสร้างดีและบำรุงรักษาง่าย</li>
                <li>สร้าง Pattern Implementation Plan สำหรับ Agent Wallboard System</li>
            </ul>
            <div class="slide-number">2/28</div>
        </section>

        <section class="slide">
            <h2>📚 ทบทวนสัปดาห์ที่แล้ว</h2>
            <h3>จากหลักการออกแบบสู่การนำไปใช้จริง</h3>
            <div class="timeline">
                <div class="timeline-container left">
                    <div class="timeline-content">
                        <h3>สัปดาห์ที่ 5: หลักการ & ภาพรวม</h3>
                        <p>เรียนรู้หลักการพื้นฐาน เช่น <strong>SOLID, DRY, KISS, YAGNI</strong>, <strong>3-Tier
                                Architecture</strong>, และสร้างแบบจำลอง <strong>C4 Model (C1-C2)</strong></p>
                    </div>
                </div>
                <div class="timeline-container right current">
                    <div class="timeline-content">
                        <h3><strong>สัปดาห์นี้ (ที่ 6): Design Patterns</strong></h3>
                        <p><strong>เรียนรู้ "สูตรสำเร็จ" หรือเครื่องมือแก้ปัญหาเฉพาะทาง (Design Patterns)
                                และการประยุกต์ใช้กับระบบ Real-time</strong></p>
                    </div>
                </div>
                <div class="timeline-container left">
                    <div class="timeline-content">
                        <h3>ต่อไปสัปดาห์ที่ 7: Component Design</h3>
                        <p>นำ Patterns ที่เรียนวันนี้มาใช้ในการออกแบบ <strong>Component Architecture (C3)</strong>
                            อย่างละเอียด</p>
                    </div>
                </div>
            </div>
            <div class="slide-number">3/28</div>
        </section>

        <section class="slide">
            <h2>🔍 Agent Wallboard System - ปัญหาที่ต้องแก้</h2>
            <h3>ความท้าทายหลักในการพัฒนา</h3>
            <div class="grid-2" style="grid-template-columns: 1fr 1fr;">
                <div class="infographic-card">
                    <div class="icon">🔌</div>
                    <h4>1. Connection Management</h4>
                    <p>จะจัดการ WebSocket connections จำนวนมาก (50-500 agents) อย่างไรไม่ให้เกิด memory leak หรือ
                        connection overflow?</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">📨</div>
                    <h4>2. Message Types ที่หลากหลาย</h4>
                    <p>จะจัดการข้อความหลายประเภท (Status Update, Chat, Alert) ที่มี format และ logic ต่างกันได้อย่างไร?
                    </p>
                </div>
                <div class="infographic-card">
                    <div class="icon">⚡</div>
                    <h4>3. Real-time Updates</h4>
                    <p>เมื่อ Agent เปลี่ยนสถานะ จะแจ้งเตือนหลายส่วน (Dashboard, Report, Supervisor)
                        พร้อมกันทันทีได้อย่างไร?</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🔐</div>
                    <h4>4. Multiple Authentication Methods</h4>
                    <p>จะรองรับการ Login หลายรูปแบบ (Local, SSO) และเพิ่มรูปแบบใหม่ในอนาคตได้ง่ายๆ อย่างไร?</p>
                </div>
            </div>
            <blockquote>💡 Design Patterns จะช่วยแก้ปัญหาเหล่านี้อย่างเป็นระบบ!</blockquote>
            <div class="slide-number">4/28</div>
        </section>

        <section class="slide">
            <h2>💭 Design Patterns คืออะไร?</h2>
            <h3>เปรียบเทียบง่ายๆ เหมือน "สูตรอาหาร" 🍳</h3>
            <div class="grid-3">
                <div class="infographic-card">
                    <h4>สูตรอาหาร<br>(Design Pattern)</h4>
                    <p>คือขั้นตอนการแก้ปัญหาที่ผ่านการพิสูจน์แล้ว</p>
                </div>
                <div class="infographic-card">
                    <h4>วัตถุดิบ<br>(Objects/Classes)</h4>
                    <p>คือส่วนประกอบในโค้ดของเราที่นำมาใช้</p>
                </div>
                <div class="infographic-card">
                    <h4>อาหารจานเด็ด<br>(Finished Software)</h4>
                    <p>คือโปรแกรมที่ทำงานได้ดีและมีคุณภาพ</p>
                </div>
            </div>
            <h4>🎯 ประโยชน์:</h4>
            <ul class="checklist">
                <li><strong>ไม่ต้องคิดใหม่ทุกครั้ง:</strong> มีแนวทางที่ทดสอบแล้วว่าได้ผลดี</li>
                <li><strong>วิธีการที่ได้รับการพิสูจน์แล้ว:</strong> ช่วยลดความเสี่ยงในโครงการ</li>
                <li><strong>ทีมเข้าใจกันได้ง่าย:</strong> สร้างภาษากลางในการสื่อสาร (เช่น "ตรงนี้เราใช้ Factory นะ")
                </li>
            </ul>
            <div class="slide-number">5/28</div>
        </section>

        <section class="slide">
            <h2>📊 ประเภทของ Design Patterns</h2>
            <h3>3 กลุ่มหลัก (Gang of Four)</h3>
            <div class="grid-3">
                <div class="infographic-card">
                    <div class="icon">🏭</div>
                    <h4>1. Creational Patterns</h4>
                    <p><strong>เกี่ยวกับการ "สร้าง" Object</strong><br>ช่วยให้การสร้าง Object
                        ยืดหยุ่นและนำกลับมาใช้ใหม่ได้ง่ายขึ้น</p>
                    <p><strong>ใช้กับ:</strong> Connection Manager, Message Creation</p>
                </div>
                <div class="infographic-card" style="border-top-color: var(--secondary-color);">
                    <div class="icon">🏗️</div>
                    <h4>2. Structural Patterns</h4>
                    <p><strong>เกี่ยวกับการ "จัดโครงสร้าง"</strong><br>ช่วยจัดระเบียบความสัมพันธ์ระหว่าง Class และ
                        Object ให้ทำงานร่วมกันเป็นโครงสร้างที่ใหญ่ขึ้น</p>
                    <p><strong>ใช้กับ:</strong> Database Integration, API Simplification</p>
                </div>
                <div class="infographic-card" style="border-top-color: var(--accent-color);">
                    <div class="icon">🎭</div>
                    <h4>3. Behavioral Patterns</h4>
                    <p><strong>เกี่ยวกับการ
                            "จัดการพฤติกรรม"</strong><br>ช่วยจัดการเรื่องการสื่อสารและความรับผิดชอบระหว่าง Object</p>
                    <p><strong>ใช้กับ:</strong> Real-time Updates, Authentication</p>
                </div>
            </div>
            <div class="slide-number">6/28</div>
        </section>

        <section class="slide separator-slide">
            <h2>กลุ่มที่ 1</h2>
            <h1>Creational Patterns</h1>
            <h3>"รูปแบบการสร้าง Object"</h3>
            <div class="slide-number">7/28</div>
        </section>

        <section class="slide">
            <h2>🏭 Singleton Pattern</h2>
            <h3>"หนึ่งเดียวในระบบ"</h3>
            <blockquote><strong><u>หลักการ:</u></strong> รับประกันว่า Class นั้นจะมี Instance (ตัวตน)
                เพียงหนึ่งเดียวเท่านั้น และมีจุดเข้าถึง (Global Access Point) ไปยัง Instance นั้นได้จากทุกที่ในโปรแกรม
            </blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: CEO ของบริษัท 🏢</h4>
                    <p>บริษัทมี CEO ได้เพียงคนเดียว ทุกแผนกต้องรายงานและรับคำสั่งจาก CEO คนเดียวกัน</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <ul>
                        <li><strong>WebSocket Connection Manager:</strong> มีตัวจัดการการเชื่อมต่อ WebSocket
                            เพียงตัวเดียวสำหรับทั้งระบบ เพื่อควบคุมดูแลการเชื่อมต่อของ Agent ทุกคน</li>
                        <li><strong>Database Connection Pool:</strong> มีคลังเก็บการเชื่อมต่อฐานข้อมูลเพียงที่เดียว
                            เพื่อให้ทุกส่วนของโปรแกรมมาหยิบใช้ร่วมกัน และควบคุมจำนวนการเชื่อมต่อ</li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> ประหยัด resource, จัดการง่าย, เป็นจุดควบคุมเดียว
                    </div>
                    <div class="anti-pattern"><strong>🔴 ข้อเสีย:</strong> หากพังจะกระทบทั้งระบบ (Single Point of
                        Failure), ทดสอบยาก</div>
                </div>
            </div>
            <div class="slide-number">8/28</div>
        </section>

        <section class="slide">
            <h2>🏭 Factory Pattern</h2>
            <h3>"โรงงานผลิตสินค้า"</h3>
            <blockquote><strong><u>หลักการ:</u></strong> สร้าง Interface สำหรับการสร้าง Object แต่ปล่อยให้ Subclass
                เป็นผู้ตัดสินใจว่าจะสร้าง Class ไหนขึ้นมาจริงๆ ซ่อนความซับซ้อนในการสร้าง Object จาก Client</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: ร้านพิซซ่า 🍕</h4>
                    <p>ลูกค้าแค่สั่ง "พิซซ่า" ที่ต้องการ (เช่น แฮม, ไก่) แต่ไม่ต้องรู้วิธีการทำหรือส่วนผสมโดยละเอียด
                        พ่อครัว (Factory) จะจัดการสร้างพิซซ่าที่ถูกต้องให้เอง</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <p><strong>Message Factory:</strong> เมื่อระบบได้รับข้อมูลดิบจาก WebSocket และต้องการแปลงเป็น Object
                        ข้อความประเภทต่างๆ:</p>
                    <ul>
                        <li>ต้องการ "Status Update" → สร้าง `StatusMessage` object</li>
                        <li>ต้องการ "Chat Message" → สร้าง `ChatMessage` object</li>
                        <li>ต้องการ "System Alert" → สร้าง `AlertMessage` object</li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> เพิ่ม message type ใหม่ได้ง่าย, จัดการ format
                        ที่แตกต่างกัน, ลดความซับซ้อนของโค้ดส่วนที่เรียกใช้</div>
                </div>
            </div>
            <div class="slide-number">9/28</div>
        </section>

        <section class="slide separator-slide">
            <h2>กลุ่มที่ 2</h2>
            <h1>Structural Patterns</h1>
            <h3>"รูปแบบการจัดโครงสร้าง"</h3>
            <div class="slide-number">10/28</div>
        </section>

        <section class="slide">
            <h2>🏗️ Adapter Pattern</h2>
            <h3>"ตัวแปลงให้คุยกันได้"</h3>
            <blockquote><strong><u>หลักการ:</u></strong> ทำให้ Interface ที่ไม่เข้ากันของ Class
                สองตัวสามารถทำงานร่วมกันได้ เปรียบเสมือนล่ามแปลภาษาหรือปลั๊กแปลงไฟ</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: ปลั๊กแปลงไฟ 🔌</h4>
                    <p>เรามีอุปกรณ์ที่ใช้ปลั๊กแบบยุโรป แต่ต้องการไปเสียบกับเต้ารับแบบอเมริกัน เราต้องใช้ "ปลั๊กแปลง"
                        (Adapter) เป็นตัวกลาง</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <ul>
                        <li><strong>Database Adapter:</strong> ระบบเก่าใช้ MSSQL (SQL commands)
                            แต่ระบบใหม่ต้องการเชื่อมต่อ MongoDB (NoSQL documents) ด้วย เราสามารถสร้าง `DatabaseAdapter`
                            เพื่อแปลงคำสั่งมาตรฐาน เช่น `db.findUser()`
                            ให้เป็นคำสั่งที่ถูกต้องสำหรับฐานข้อมูลแต่ละชนิดได้</li>
                        <li><strong>API Adapter:</strong> หากต้องเชื่อมต่อกับระบบภายนอกที่ส่งข้อมูลมาเป็น XML
                            เราสามารถสร้าง `ApiAdapter` เพื่อแปลง XML ให้เป็น JSON ที่ระบบเราเข้าใจและใช้งานได้ทันที
                        </li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> ทำให้ระบบเก่าและใหม่ทำงานร่วมกันได้,
                        ไม่ต้องเขียนโค้ดหลักใหม่ทั้งหมด</div>
                </div>
            </div>
            <div class="slide-number">11/28</div>
        </section>

        <section class="slide">
            <h2>🏗️ Facade Pattern</h2>
            <h3>"หน้าต่างเดียวที่ซ่อนความซับซ้อน"</h3>
            <blockquote><strong><u>หลักการ:</u></strong> สร้าง Interface ที่เรียบง่ายขึ้นมาหนึ่งอัน
                เพื่อเป็นหน้าต่างสำหรับติดต่อกับระบบย่อย (Subsystem) ที่มีความซับซ้อนอยู่เบื้องหลัง</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: แผนกต้อนรับธนาคาร 🏦</h4>
                    <p>แทนที่เราจะต้องวิ่งไปติดต่อแผนกแคชเชียร์, แผนกสินเชื่อ, แผนก IT เอง เราแค่ไปที่ "แผนกต้อนรับ"
                        (Facade) ที่เดียว แล้วเขาจะประสานงานส่วนที่ซับซ้อนทั้งหมดให้เรา</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <ul>
                        <li><strong>Dashboard API Facade:</strong> Frontend ต้องการข้อมูล Dashboard ซึ่งจริงๆ
                            แล้วต้องเรียก Agent Service + Status Service + Alert Service เราสามารถสร้าง
                            `DashboardFacade` ที่มี Method เดียวคือ `getDashboardData()`
                            ซึ่งเบื้องหลังจะไปรวบรวมข้อมูลทั้งหมดมาให้ ทำให้ Frontend เรียกใช้งานง่าย</li>
                        <li><strong>Authentication Facade:</strong> การ login อาจซับซ้อน (ตรวจ username -> hash password
                            -> สร้าง session -> บันทึก log) เราสร้าง Facade ให้เรียกแค่ `auth.login(user, pass)` ก็พอ
                        </li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> ใช้งานง่าย, ซ่อนความซับซ้อน, ลดการพึ่งพาระหว่าง
                        Client กับระบบภายใน (Loose Coupling)</div>
                </div>
            </div>
            <div class="slide-number">12/28</div>
        </section>

        <section class="slide separator-slide">
            <h2>กลุ่มที่ 3</h2>
            <h1>Behavioral Patterns</h1>
            <h3>"รูปแบบการจัดการพฤติกรรม"</h3>
            <div class="slide-number">13/28</div>
        </section>

        <section class="slide">
            <h2>🎭 Observer Pattern</h2>
            <h3>"ระบบแจ้งข่าวอัตโนมัติ"</h3>
            <blockquote><strong><u>หลักการ:</u></strong> สร้างความสัมพันธ์แบบ One-to-Many ระหว่าง Object โดยเมื่อ Object
                หนึ่ง (Subject) มีการเปลี่ยนแปลงสถานะ Object อื่นๆ (Observers) ที่คอย "สังเกตการณ์"
                อยู่จะได้รับการแจ้งเตือนและอัปเดตโดยอัตโนมัติ</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: การ Follow ในโซเชียลมีเดีย 📱</h4>
                    <p>เรา (Observer) กด Follow เพจข่าว (Subject) เมื่อเพจข่าวโพสต์อะไรใหม่ เราก็จะได้รับการแจ้งเตือน
                        (Notification) ทันที โดยไม่ต้องเข้าไปรีเฟรชหน้าเพจเอง</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <p><strong>Agent Status Broadcasting:</strong></p>
                    <ul>
                        <li><strong>Subject:</strong> `Agent` object (คนที่เปลี่ยนสถานะ)</li>
                        <li><strong>Observers:</strong> `SupervisorDashboard`, `ManagerReport`, `TeamLeaderScreen`</li>
                        <li><strong>เมื่อ Agent เปลี่ยนสถานะ:</strong> Subject จะ "แจ้งข่าว" ไปยัง Observer
                            ทุกตัวที่ลงทะเบียนไว้ ทำให้ทุกหน้าจออัปเดตพร้อมกันแบบ Real-time</li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> เป็นหัวใจของ Real-time updates, ไม่ต้องคอยถาม
                        (Polling) ซ้ำๆ ให้เปลืองแรง</div>
                </div>
            </div>
            <div class="slide-number">14/28</div>
        </section>

        <section class="slide">
            <h2>🎭 Strategy Pattern</h2>
            <h3>"หลายวิธี สู่หนึ่งเป้าหมาย"</h3>
            <blockquote><strong><u>หลักการ:</u></strong> กำหนดกลุ่มของ Algorithm (วิธีแก้ปัญหา) ห่อหุ้มแต่ละอันไว้ใน
                Class แยกกัน และทำให้มันสามารถสลับสับเปลี่ยนกันได้ ทำให้ Algorithm สามารถเปลี่ยนแปลงได้โดยไม่กระทบกับ
                Client ที่เรียกใช้</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: GPS Navigation 🗺️</h4>
                    <p>เป้าหมายคือการเดินทางจาก A ไป B แต่มีได้หลาย "กลยุทธ์" (Strategy) เช่น เส้นทางที่เร็วที่สุด
                        (ทางด่วน), เส้นทางที่สั้นที่สุด, หรือเส้นทางที่ประหยัดที่สุด
                        เราสามารถเลือกสลับไปมาได้ตามสถานการณ์</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <p><strong>Authentication Strategies:</strong></p>
                    <ul>
                        <li><strong>เป้าหมาย:</strong> ผู้ใช้เข้าระบบได้</li>
                        <li><strong>กลยุทธ์ (Strategies):</strong>
                            <ul>
                                <li><code>LocalStrategy</code> (ใช้ Username/Password ในระบบเรา)</li>
                                <li><code>SSOStrategy</code> (ใช้ Single Sign-On จากระบบอื่น)</li>
                                <li><code>LDAPStrategy</code> (ใช้ระบบขององค์กรใหญ่)</li>
                            </ul>
                        </li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> เพิ่ม/แก้ไขวิธีการ Login
                        ได้ง่ายโดยไม่ต้องรื้อโค้ดหลัก, สอดคล้องกับ Open/Closed Principle ของ SOLID</div>
                </div>
            </div>
            <div class="slide-number">15/28</div>
        </section>

        <section class="slide separator-slide">
            <h2>กลุ่มที่ 4 (เพิ่มเติม)</h2>
            <h1>Architectural & Real-time Patterns</h1>
            <h3>"รูปแบบสำหรับภาพใหญ่และความทนทาน"</h3>
            <div class="slide-number">16/28</div>
        </section>

        <section class="slide">
            <h2>ความแตกต่าง: Design vs. Architectural Patterns 🏗️</h2>
            <h3>เปรียบเทียบกับการสร้างบ้าน</h3>
            <div class="grid-2">
                <div class="infographic-card">
                    <div class="icon">🏛️</div>
                    <h4>Architectural Pattern<br>(รูปแบบสถาปัตยกรรม)</h4>
                    <p>เปรียบเสมือน <strong>"แบบแปลนหลักของบ้าน"</strong><br>เป็นการตัดสินใจในภาพใหญ่ที่สุด เช่น
                        บ้านจะเป็นแบบ "ทาวน์เฮาส์" หรือ "บ้านเดี่ยวสองชั้น" ซึ่งจะกำหนดโครงสร้างหลักทั้งหมด</p>
                    <p><strong>ระดับ:</strong> Macro (ภาพรวมระบบ)</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🧱</div>
                    <h4>Design Pattern<br>(รูปแบบการออกแบบ)</h4>
                    <p>เปรียบเสมือน <strong>"เทคนิคการก่อสร้างภายใน"</strong><br>เป็นการแก้ปัญหาเฉพาะจุด เช่น
                        "เทคนิคการเดินสายไฟในห้องครัว" หรือ "วิธีการสร้างบันไดให้แข็งแรง"
                        ซึ่งทำงานอยู่ภายในกรอบของแบบแปลนหลัก</p>
                    <p><strong>ระดับ:</strong> Micro (ระดับ Component/Class)</p>
                </div>
            </div>
            <blockquote>สรุป: Architectural Pattern คือการวางโครงสร้างใหญ่ ส่วน Design Pattern คือวิธีแก้ปัญหาเล็กๆ
                ภายในโครงสร้างนั้น</blockquote>
            <div class="slide-number">17/28</div>
        </section>

        <section class="slide">
            <h2>ทำไม Pub/Sub และ Circuit Breaker ถึงเป็น Architectural?</h2>
            <h3>เพราะเป็นการตัดสินใจที่ส่งผลต่อทั้งระบบ</h3>
            <div class="grid-2">
                <div class="infographic-card">
                    <div class="icon">📡</div>
                    <h4>Publisher-Subscriber (Pub/Sub)</h4>
                    <p><strong>ไม่ใช่แค่</strong> Object หนึ่งคุยกับอีก Object หนึ่ง แต่เป็น
                        <strong>"รูปแบบการสื่อสารหลักของทั้งระบบ"</strong> ที่ทำให้ Service ใหญ่ๆ
                        คุยกันได้โดยไม่ต้องรู้จักกันโดยตรง (Decoupling) ผ่านตัวกลาง (Message Broker) ซึ่งส่งผลต่อ
                        Scalability ในภาพรวม</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🛡️</div>
                    <h4>Circuit Breaker</h4>
                    <p>รูปแบบนี้ไม่ได้จัดการ Logic ภายใน Component เดียว แต่จัดการ <strong>"การสื่อสารระหว่าง
                            Service"</strong> เพื่อป้องกันความล้มเหลวแบบลูกโซ่ (Cascading Failures) ซึ่งเป็นการดูแล
                        <strong>"ความเสถียรและความทนทาน (Resilience) ของทั้งระบบ"</strong></p>
                </div>
            </div>
            <blockquote>การเลือกใช้ Patterns เหล่านี้ คือก้าวสำคัญของการเปลี่ยนมุมมองจาก Developer ไปสู่ Architect ครับ
            </blockquote>
            <div class="slide-number">18/28</div>
        </section>

        <section class="slide">
            <h2>⚡ Publisher-Subscriber Pattern</h2>
            <h3>สำหรับระบบ Real-time ขนาดใหญ่</h3>
            <blockquote>คล้ายกับ Observer แต่มีความ Decoupled (ไม่ผูกติดกัน) มากกว่า โดยมี "ตัวกลาง" (Message
                Broker/Event Channel) เข้ามาคั่น ทำให้ Publisher ไม่จำเป็นต้องรู้จัก Subscriber เลย</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: สถานีวิทยุ 📺</h4>
                    <p><strong>สถานีวิทยุ (Publisher)</strong> แค่ส่งสัญญาณออกไป ไม่รู้ว่าใครกำลังฟังอยู่บ้าง
                        <strong>ผู้ฟัง (Subscriber)</strong> แค่จูนคลื่นให้ตรงกับช่อง (Channel) ก็จะได้รับสัญญาณเอง</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <p><strong>Event Broadcasting:</strong></p>
                    <ul>
                        <li><strong>Publisher:</strong> Agent Status Service</li>
                        <li><strong>Channel:</strong> "agent-status-updates" WebSocket Event</li>
                        <li><strong>Subscribers:</strong> `SupervisorDashboard`, `ManagerReports`, `TeamLeaderScreen`
                        </li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> Scalable, Decoupled,
                        เหมาะกับระบบที่ซับซ้อนและมีการสื่อสารข้าม Service</div>
                </div>
            </div>
            <div class="slide-number">19/28</div>
        </section>

        <section class="slide">
            <h2>🔄 Circuit Breaker Pattern</h2>
            <h3>ป้องกันระบบล่มแบบลูกโซ่</h3>
            <blockquote><strong><u>หลักการ:</u></strong> เป็น Proxy ที่คอยตรวจสอบความล้มเหลวของการเรียกใช้ Service
                ภายนอก หากล้มเหลวเกินเกณฑ์ที่กำหนด มันจะ "ตัดวงจร" (Open) คือหยุดส่งคำขอไปชั่วคราว และคืนค่า Error
                หรือค่าสำรอง (Fallback) ทันที เพื่อป้องกันไม่ให้ระบบหลักล่มตามไปด้วย</blockquote>
            <div class="grid-2">
                <div>
                    <h4>เปรียบเทียบ: เบรกเกอร์ไฟฟ้า 🏠</h4>
                    <p>เมื่อเกิดไฟลัดวงจร, เบรกเกอร์จะตัดไฟทันทีเพื่อป้องกันไม่ให้เครื่องใช้ไฟฟ้าอื่นๆ
                        เสียหายหรือเกิดไฟไหม้ และเมื่อแก้ไขแล้วก็สามารถสับขึ้นเพื่อใช้งานใหม่ได้</p>
                </div>
                <div>
                    <h4>การประยุกต์ใช้ใน Wallboard:</h4>
                    <p><strong>Database Connection Resilience:</strong></p>
                    <ul>
                        <li><strong>ปกติ (CLOSED):</strong> ส่งคำขอไปที่ Database ตามปกติ</li>
                        <li><strong>Database ล่ม (OPEN):</strong> Circuit Breaker ตัดการเชื่อมต่อ
                            และอาจจะแสดงข้อมูลเก่าจาก Cache แทน เพื่อให้ระบบทำงานต่อได้</li>
                        <li><strong>ทดสอบ (HALF-OPEN):</strong> หลังจากผ่านไปสักพัก จะลองส่งคำขอไป 1 ครั้ง
                            ถ้าสำเร็จจะกลับสู่สถานะ CLOSED แต่ถ้าล้มเหลวจะกลับไป OPEN อีกครั้ง</li>
                    </ul>
                    <div class="solution"><strong>🟢 ข้อดี:</strong> ป้องกันระบบล่มแบบลูกโซ่, มีกลไกฟื้นตัวเอง (Auto
                        recovery)</div>
                </div>
            </div>
            <div class="slide-number">20/28</div>
        </section>

        <section class="slide">
            <h2>🎯 Pattern Selection สำหรับ Agent Wallboard</h2>
            <h3>เลือก Pattern อย่างไรให้เหมาะสม</h3>
            <table style="font-size: 0.9em; line-height: 1.5;">
                <thead>
                    <tr>
                        <th>ปัญหา (Problem)</th>
                        <th>Pattern ที่เหมาะสม</th>
                        <th>เหตุผล (Why)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>จัดการ WebSocket connections จำนวนมาก</td>
                        <td><strong>Singleton</strong></td>
                        <td>ต้องการตัวจัดการเดียว เพื่อควบคุมทรัพยากรและป้องกัน conflict ของการเชื่อมต่อ</td>
                    </tr>
                    <tr>
                        <td>สร้าง message หลายประเภท (Status, Chat, Alert)</td>
                        <td><strong>Factory</strong></td>
                        <td>แยก Logic การสร้าง Object ที่ซับซ้อนและแตกต่างกันตามประเภทของ Message</td>
                    </tr>
                    <tr>
                        <td>เชื่อมต่อฐานข้อมูลได้ทั้ง MSSQL และ MongoDB</td>
                        <td><strong>Adapter</strong></td>
                        <td>ทำให้ Interface ของ Database ที่ต่างกันสามารถทำงานร่วมกันได้</td>
                    </tr>
                    <tr>
                        <td>Dashboard API ต้องดึงข้อมูลจากหลาย Service ย่อย</td>
                        <td><strong>Facade</strong></td>
                        <td>ซ่อนความซับซ้อนเบื้องหลัง และสร้าง API ที่ใช้ง่ายสำหรับ Frontend</td>
                    </tr>
                    <tr>
                        <td>อัปเดตสถานะ Agent แบบ Real-time ไปยังหลายหน้าจอ</td>
                        <td><strong>Observer / Pub-Sub</strong></td>
                        <td>กระจายการเปลี่ยนแปลงไปยังหลายส่วนพร้อมกันอย่างมีประสิทธิภาพ โดยไม่ต้อง Polling</td>
                    </tr>
                    <tr>
                        <td>รองรับวิธีการ Login หลายรูปแบบ (Local, SSO, LDAP)</td>
                        <td><strong>Strategy</strong></td>
                        <td>สลับสับเปลี่ยน Algorithm การ Login ได้โดยไม่ต้องแก้โค้ดหลักเมื่อมีรูปแบบใหม่เพิ่ม</td>
                    </tr>
                    <tr>
                        <td>ป้องกันระบบล่มเมื่อ Database หรือ Service ภายนอกล่มบ่อย</td>
                        <td><strong>Circuit Breaker</strong></td>
                        <td>เพิ่มความทนทาน (Resilience) ให้ระบบ ไม่ให้ล่มตามกันไป และมีกลไกฟื้นตัว</td>
                    </tr>
                </tbody>
            </table>
            <div class="slide-number">21/28</div>
        </section>

        <section class="slide">
            <h2>📋 Implementation Strategy</h2>
            <h3>วางแผนการพัฒนาทีละขั้น</h3>
            <div class="timeline">
                <div class="timeline-container left">
                    <div class="timeline-content">
                        <h3>Phase 1: Core Infrastructure</h3>
                        <p>ใช้ <strong>Singleton</strong> (WebSocket Manager, DB Pool) และ <strong>Factory</strong>
                            (Message Factory) เพื่อสร้างระบบพื้นฐานให้ทำงานได้</p>
                    </div>
                </div>
                <div class="timeline-container right">
                    <div class="timeline-content">
                        <h3>Phase 2: Integration Layer</h3>
                        <p>ใช้ <strong>Adapter</strong> (Database) และ <strong>Facade</strong> (API)
                            เพื่อเชื่อมต่อระบบต่างๆ และสร้าง Interface ที่ใช้งานง่าย</p>
                    </div>
                </div>
                <div class="timeline-container left">
                    <div class="timeline-content">
                        <h3>Phase 3: Real-time Features</h3>
                        <p>ใช้ <strong>Observer/Pub-Sub</strong> เพื่อสร้างฟีเจอร์หัวใจหลักของระบบ คือ Real-time updates
                        </p>
                    </div>
                </div>
                <div class="timeline-container right">
                    <div class="timeline-content">
                        <h3>Phase 4: Resilience & Flexibility</h3>
                        <p>ใช้ <strong>Strategy</strong> (Auth) และ <strong>Circuit Breaker</strong> (DB Resilience)
                            เพื่อให้ระบบมั่นคงและยืดหยุ่นต่อการเปลี่ยนแปลง</p>
                    </div>
                </div>
            </div>
            <div class="slide-number">22/28</div>
        </section>

        <section class="slide">
            <h2>🛠️ Workshop: Pattern Design Exercise</h2>
            <h3>กิจกรรมออกแบบ Patterns (15 นาที)</h3>
            <h4>สถานการณ์: ระบบห้องสมุดอัจฉริยะ</h4>
            <div class="grid-2">
                <div>
                    <p>คุณได้รับมอบหมายให้ออกแบบระบบห้องสมุด โดยมี Requirement ดังนี้:</p>
                    <ul>
                        <li>นักเรียนค้นหาหนังสือผ่านแอป</li>
                        <li>มีหนังสือหลายประเภท: นิยาย, วิชาการ, การ์ตูน ซึ่งมีข้อมูลไม่เหมือนกัน</li>
                        <li>เมื่อมีหนังสือใหม่เข้าหมวดที่สนใจ → ต้องแจ้งเตือนนักเรียนที่ติดตามหมวดนั้นๆ</li>
                        <li>รองรับการค้นหาหลายวิธี: ตามชื่อ, ตามผู้แต่ง, ตามหมวด</li>
                        <li>ต้องเชื่อมต่อกับระบบ API ของห้องสมุดมหาวิทยาลัยอื่นได้ ซึ่ง API แต่ละที่ก็ไม่เหมือนกัน</li>
                    </ul>
                </div>
                <div>
                    <h4>คำถามสำหรับกลุ่ม (4-5 คน):</h4>
                    <ol style="padding-left:20px;">
                        <li>ควรใช้ Design Patterns อะไรบ้างในระบบนี้?</li>
                        <li>แต่ละ Pattern ใช้แก้ปัญหาอะไร?</li>
                        <li>ลองวาดแผนภาพง่ายๆ แสดงความสัมพันธ์</li>
                    </ol>
                </div>
            </div>
            <div class="slide-number">23/28</div>
        </section>

        <section class="slide">
            <h2>💡 Workshop Solution (เฉลย)</h2>
            <h3>Patterns ที่ควรใช้ในระบบห้องสมุด</h3>
            <div class="grid-2" style="grid-template-columns: 1fr 1fr;">
                <div class="infographic-card">
                    <div class="icon">🔔</div>
                    <h4>Observer Pattern</h4>
                    <p>ใช้สำหรับแจ้งเตือนนักเรียน (Subscribers) เมื่อมีหนังสือใหม่ (Subject) เข้ามาในหมวดที่สนใจ</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🏭</div>
                    <h4>Factory Pattern</h4>
                    <p>ใช้สร้าง Object ของหนังสือแต่ละประเภท (นิยาย, วิชาการ, การ์ตูน)
                        ซึ่งอาจมีคุณสมบัติและวิธีการสร้างที่แตกต่างกัน</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🗺️</div>
                    <h4>Strategy Pattern</h4>
                    <p>วิธีค้นหาหลากหลาย (ByTitle, ByAuthor, ByCategory) โดยไม่กระทบโค้ดหลักที่เรียกใช้การค้นหา</p>
                </div>
                <div class="infographic-card">
                    <div class="icon">🔌</div>
                    <h4>Adapter Pattern</h4>
                    <p>ใช้เป็นตัวกลางในการเชื่อมต่อกับ API ของห้องสมุดอื่น ซึ่งอาจมีรูปแบบ Request/Response
                        ที่แตกต่างกัน</p>
                </div>
            </div>
            <div class="slide-number">24/28</div>
        </section>

        <section class="slide">
            <h2>📊 Benefits Analysis</h2>
            <h3>ประโยชน์ของการใช้ Patterns</h3>
            <div class="grid-2">
                <div class="infographic-card">
                    <h4>📈 ในระยะสั้น</h4>
                    <ul style="text-align: left; padding-left: 20px; list-style-type: disc;">
                        <li>โค้ดเป็นระเบียบมากขึ้น</li>
                        <li>ทีมเข้าใจตรงกันได้ง่าย</li>
                        <li>แก้ไขปัญหาเฉพาะจุดได้ดี</li>
                    </ul>
                </div>
                <div class="infographic-card">
                    <h4>📈 ในระยะยาว</h4>
                    <ul style="text-align: left; padding-left: 20px; list-style-type: disc;">
                        <li>บำรุงรักษาง่ายขึ้น (Maintainability)</li>
                        <li>เพิ่ม feature ใหม่ได้เร็ว (Extensibility)</li>
                        <li>ขยายระบบได้ดีกว่า (Scalability)</li>
                    </ul>
                </div>
            </div>
            <h3>📊 ROI (Return on Investment)</h3>
            <ul style="padding-left: 0; list-style: none;">
                <li><strong>ลงทุน:</strong> เวลาเรียนรู้และวางแผนการใช้ Patterns</li>
                <li><strong>ผลตอบแทน:</strong> ประหยัดเวลาในการพัฒนาและบำรุงรักษาในอนาคตมหาศาล</li>
                <li><strong>จุดคุ้มทุน (Break-even):</strong> โดยทั่วไปจะเห็นผลชัดเจนใน 3-6 เดือน</li>
            </ul>
            <div class="anti-pattern">
                <h4>⚠️ ข้อควรระวัง</h4>
                <p>อย่าใช้ Pattern เพื่อแค่จะได้ใช้ (Over-engineering) ให้เลือกใช้เมื่อมันช่วยแก้ปัญหาได้จริง
                    และระวังการออกแบบที่ซับซ้อนเกินความจำเป็น</p>
            </div>
            <div class="slide-number">25/28</div>
        </section>

        <section class="slide active">
            <h2>🎯 สรุปผลการเลือก Design Pattern สำหรับ Agent Wallboard</h2>
            <h3>จับคู่ "ปัญหา" กับ "ทางออก" ที่เหมาะสม</h3>
            <p>จากการวิเคราะห์ความท้าทายหลักในการพัฒนา (Pain Points) เราสามารถเลือกใช้ Design Patterns และ
                Architectural Patterns ที่เหมาะสมเพื่อแก้ปัญหาแต่ละส่วนได้อย่างเป็นระบบ ดังนี้</p>
            <table style="font-size: 0.85em; line-height: 1.4;">
                <thead>
                    <tr>
                        <th>ความท้าทายหลัก (Challenge)</th>
                        <th>Pattern ที่เลือกใช้</th>
                        <th>เหตุผลที่เลือก (Rationale)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>🔌 <strong>การจัดการ Connection จำนวนมาก</strong></td>
                        <td><strong>Singleton Pattern</strong></td>
                        <td>เพื่อให้มี <code>WebSocketManager</code> เพียงตัวเดียวในระบบ ป้องกันการสร้าง
                            connection ซ้ำซ้อนและจัดการทรัพยากรได้อย่างมีประสิทธิภาพ </td>
                    </tr>
                    <tr>
                        <td>📨 <strong>การจัดการ Message หลายประเภท</strong></td>
                        <td><strong>Factory Pattern</strong></td>
                        <td>เพื่อแยกส่วนการสร้าง Object ของข้อความแต่ละประเภท (Status, Chat, Alert)
                            ออกจากกัน ทำให้เพิ่มประเภทข้อความใหม่ในอนาคตได้ง่าย </td>
                    </tr>
                    <tr>
                        <td>⚡ <strong>การอัปเดตข้อมูลแบบ Real-time</strong></td>
                        <td><strong>Observer / Pub-Sub Pattern</strong></td>
                        <td>เพื่อกระจายการเปลี่ยนแปลงสถานะ (Event) จาก Agent (Subject)
                            ไปยังทุกส่วนที่เกี่ยวข้อง (Observers) เช่น Dashboard, Report พร้อมกันทันที </td>
                    </tr>
                    <tr>
                        <td>🔐 <strong>การรองรับ Login หลายรูปแบบ</strong></td>
                        <td><strong>Strategy Pattern</strong></td>
                        <td>เพื่อแยก Algorithm การยืนยันตัวตนแต่ละแบบ (Local, SSO) ออกจากกัน
                            ทำให้สามารถสลับหรือเพิ่มวิธีการใหม่ได้โดยไม่กระทบโค้ดหลัก </td>
                    </tr>
                    <tr>
                        <td>🛡️ <strong>ป้องกันระบบล่มเมื่อ Service ภายนอกมีปัญหา</strong></td>
                        <td><strong>Circuit Breaker Pattern</strong></td>
                        <td>เพื่อเพิ่มความทนทาน (Resilience) ให้ระบบ โดยการตัดการเชื่อมต่อไปยัง Database
                            หรือ API ภายนอกชั่วคราวเมื่อเกิดปัญหา ป้องกันไม่ให้ระบบหลักล่มตามไปด้วย </td>
                    </tr>
                </tbody>
            </table>
            <div class="slide-number">26/30</div>
        </section>

        <section class="slide active">
            <h2>🚀 ขั้นต่อไป: จาก Patterns สู่ Component Design (C3)</h2>
            <h3>ทำไมต้องมี C3 และมันต่อเนื่องจากสัปดาห์นี้อย่างไร?</h3>


            <blockquote>Design Patterns ที่เราเลือกในวันนี้ คือ <strong>"พิมพ์เขียว (Blueprint)"</strong>
                สำหรับการสร้างส่วนประกอบย่อย (Components) ที่จับต้องได้ในสัปดาห์หน้า ซึ่งก็คือการออกแบบสถาปัตยกรรมระดับ
                <strong>C3 (Component Level)</strong> นั่นเอง</blockquote>

            <h3>ความเชื่อมโยงจาก Pattern สู่ Component</h3>
            <div class="grid-2">
                <div class="infographic-card">
                    <h4>ภาพรวม C2 (สัปดาห์ที่ 5)</h4>
                    <p>เรารู้ว่าระบบประกอบด้วย "Container" หรือ "กล่อง" อะไรบ้าง เช่น <strong>API Server,
                            Frontend App, Database</strong> แต่เรายังไม่รู้ว่า "ข้างในกล่อง" มีอะไร</p>
                </div>
                <div class="infographic-card">
                    <h4>พิมพ์เขียว Patterns (สัปดาห์ที่ 6)</h4>
                    <p>เราได้ "สูตร" หรือ "แบบแผน" ในการสร้างชิ้นส่วนต่างๆ เช่น <strong>Singleton</strong>
                        สำหรับตัวจัดการ Connection, <strong>Strategy</strong> สำหรับการ Login</p>
                </div>
            </div>

            <h3>แล้วทำไมต้องมี C3? (สัปดาห์ที่ 7)</h3>
            <p>C3 คือขั้นตอนที่เราจะ <strong>"เปิดกล่อง C2"</strong> และนำ <strong>"พิมพ์เขียวจาก Patterns"</strong>
                มาประกอบเป็นชิ้นส่วนจริงข้างในครับ:</p>
            <ul>
                <li>C3 คือ <strong>แผนผังการเดินสายไฟภายในระบบ</strong> ที่บอกว่าแต่ละ Component
                    มีหน้าที่อะไร มี Interface แบบไหน และสื่อสารกันอย่างไร </li>
                <li><strong>ตัวอย่าง:</strong>
                    <ul>
                        <li>Pattern <strong>Singleton</strong> จะถูกสร้างเป็น <code>WebSocketManager Component</code>
                        </li>
                        <li>Pattern <strong>Strategy</strong> จะถูกนำไปใช้ใน
                            <code>AuthenticationService Component</code></li>
                        <li>Pattern <strong>Observer</strong> คือพฤติกรรมหลักของ
                            <code>AgentStatusService Component</code></li>
                    </ul>
                </li>
            </ul>
            <div class="solution">
                <strong>สรุป:</strong> หากไม่มี C3 ก็เหมือนมีแค่แบบแปลนบ้านโดยรวม (C2) และเทคนิคการก่อสร้าง (Patterns)
                แต่ยังขาด <strong>"แบบขยายรายละเอียด"</strong> ที่จะบอกว่าแต่ละห้องมีอะไรบ้างและเชื่อมต่อกันอย่างไร
                ซึ่งจำเป็นอย่างยิ่งสำหรับทีมพัฒนาในการนำไปสร้างโค้ดจริงครับ
            </div>
            <div class="slide-number">27/30</div>


        </section>


        <section class="slide">
            <h2>🎬 สรุปการเรียนรู้</h2>
            <h3>Key Takeaways</h3>
            <ul>
                <li><strong>Design Patterns = เครื่องมือแก้ปัญหา:</strong> ใช้เมื่อมีปัญหาจริง ไม่ใช่แฟชั่น</li>
                <li><strong>3 ประเภทหลัก:</strong> Creational (สร้าง), Structural (จัดโครงสร้าง), Behavioral
                    (จัดการพฤติกรรม)</li>
                <li><strong>Patterns สำหรับ Real-time Systems:</strong> Observer/Pub-Sub (Updates), Circuit Breaker
                    (Resilience)</li>
                <li><strong>Pattern Selection Process:</strong> วิเคราะห์ปัญหาก่อน → เลือก Pattern ที่เหมาะสม →
                    พิจารณาความซับซ้อนที่เพิ่มขึ้น</li>
            </ul>
            <blockquote>🚀 เตรียมพร้อมสำหรับสัปดาห์หน้า: Component Architecture Design!</blockquote>
            <div class="slide-number">26/28</div>
        </section>

        <section class="slide">
            <h2>📋 การประเมินผล และ Assignment</h2>
            <h3>Assignment: Design Patterns Implementation Strategy (10%)</h3>
            <ol style="padding-left: 1.5em; list-style-type: decimal;">
                <li><strong>วิเคราะห์ Agent Wallboard System (40 คะแนน):</strong> ระบุปัญหา, เลือก Patterns ที่เหมาะสม
                    พร้อมเหตุผล</li>
                <li><strong>ออกแบบ Implementation Plan (40 คะแนน):</strong> วางแผนการพัฒนาเป็น phases, กำหนด timeline
                    และ priorities</li>
                <li><strong>สร้าง Pattern Relationship Diagram (20 คะแนน):</strong> แสดงความสัมพันธ์ระหว่าง Patterns
                    และการทำงานร่วมกัน</li>
            </ol>
            <p><strong>📅 กำหนดส่ง:</strong> สัปดาห์หน้าก่อนเรียน</p>
            <p><strong>📄 รูปแบบ:</strong> PDF 3-5 หน้า พร้อม diagrams</p>
            <div class="slide-number">27/28</div>
        </section>

        <section class="slide title-slide">
            <h1>Q&A</h1>
            <h3>มีคำถามอะไรไหมครับ?</h3>
            <div class="slide-number">28/28</div>
        </section>
    </div>

    <div class="presentation-controls">
        <button id="prev-btn" class="nav-btn" title="สไลด์ก่อนหน้า">‹</button>
        <span id="slide-counter"></span>
        <button id="next-btn" class="nav-btn" title="สไลด์ถัดไป">›</button>
        <button id="font-decrease-btn" class="font-btn" title="ลดขนาดตัวอักษร">-</button>
        <button id="font-increase-btn" class="font-btn" title="เพิ่มขนาดตัวอักษร">+</button>
        <button id="fullscreen-btn" class="fullscreen-btn" title="เต็มจอ">⛶</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const slides = document.querySelectorAll('.slide');
            const nextBtn = document.getElementById('next-btn');
            const prevBtn = document.getElementById('prev-btn');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const slideCounter = document.getElementById('slide-counter');
            const progressBar = document.getElementById('progress-bar');
            const fontIncreaseBtn = document.getElementById('font-increase-btn');
            const fontDecreaseBtn = document.getElementById('font-decrease-btn');
            const body = document.body;

            let currentFontSize = 20; // Base font size in pixels, adjusted to 20px
            const FONT_SIZE_STEP = 1;
            const MIN_FONT_SIZE = 16; // Minimum font size
            const MAX_FONT_SIZE = 28; // Maximum font size

            let currentSlideIndex = 0;
            const totalSlides = slides.length;

            function updateFontSize() {
                body.style.fontSize = `${currentFontSize}px`;
            }

            function showSlide(index) {
                if (index < 0 || index >= totalSlides) return;

                slides.forEach((slide, i) => {
                    slide.classList.toggle('active', i === index);
                });

                if (slides[index].scrollTop > 0) {
                    slides[index].scrollTop = 0;
                }

                currentSlideIndex = index;
                updateControls();
            }

            function updateControls() {
                const currentNumber = currentSlideIndex + 1;
                slideCounter.textContent = `${currentNumber} / ${totalSlides}`;

                const progressPercentage = (currentNumber / totalSlides) * 100;
                progressBar.style.width = `${progressPercentage}%`;

                prevBtn.disabled = currentSlideIndex === 0;
                nextBtn.disabled = currentSlideIndex >= totalSlides - 1;

                slides.forEach((slide, i) => {
                    const slideNumberElem = slide.querySelector('.slide-number');
                    if (slideNumberElem) {
                        slideNumberElem.textContent = `${i + 1}/${totalSlides}`;
                    }
                });
            }

            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        alert(`ไม่สามารถเข้าสู่โหมดเต็มจอได้: ${err.message}`);
                    });
                } else if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }

            fontIncreaseBtn.addEventListener('click', () => {
                if (currentFontSize < MAX_FONT_SIZE) {
                    currentFontSize += FONT_SIZE_STEP;
                    updateFontSize();
                }
            });

            fontDecreaseBtn.addEventListener('click', () => {
                if (currentFontSize > MIN_FONT_SIZE) {
                    currentFontSize -= FONT_SIZE_STEP;
                    updateFontSize();
                }
            });

            nextBtn.addEventListener('click', () => showSlide(currentSlideIndex + 1));
            prevBtn.addEventListener('click', () => showSlide(currentSlideIndex - 1));
            fullscreenBtn.addEventListener('click', toggleFullscreen);

            document.addEventListener('keydown', (event) => {
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

                if (event.key === 'ArrowRight' || event.key === ' ') {
                    event.preventDefault();
                    nextBtn.click();
                } else if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    prevBtn.click();
                } else if (event.key === 'f' || event.key === 'F') {
                    event.preventDefault();
                    toggleFullscreen();
                } else if (event.key === '+' || event.key === '=') {
                    event.preventDefault();
                    fontIncreaseBtn.click();
                } else if (event.key === '-' || event.key === '_') {
                    event.preventDefault();
                    fontDecreaseBtn.click();
                }
            });

            updateFontSize(); // Set initial font size
            showSlide(0);
        });
    </script>
</body>

</html>